<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面向对象2</title>
      <link href="/posts/61f0.html"/>
      <url>/posts/61f0.html</url>
      
        <content type="html"><![CDATA[<h3 id="21、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型"><a href="#21、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型" class="headerlink" title="21、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?"></a>21、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?</h3><p>考察点：JAVA  多态<br>回答：<br>方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。重写 Overriding是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的方法是可以改变返回值的类型。</p><h3 id="22、abstract-class-和-interface-有什么区别"><a href="#22、abstract-class-和-interface-有什么区别" class="headerlink" title="22、abstract class 和 interface 有什么区别?"></a>22、abstract class 和 interface 有什么区别?</h3><p>考察点：抽象类<br>回答：<br>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其<br>类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义 static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><h3 id="23、Static-Nested-Class-和-Inner-Class-的不同"><a href="#23、Static-Nested-Class-和-Inner-Class-的不同" class="headerlink" title="23、Static Nested Class 和 Inner Class 的不同"></a>23、Static Nested Class 和 Inner Class 的不同</h3><p>考察点：声明<br>回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概念很重要, 许多人对这个概念模糊.有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member).</p><h3 id="24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p>考察点：对象<br>回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><h3 id="25、Java-的接口和-C-的虚类的相同和不同处。"><a href="#25、Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="25、Java 的接口和 C++的虚类的相同和不同处。"></a>25、Java 的接口和 C++的虚类的相同和不同处。</h3><p>考察点：接口<br>回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public.一个类可以实现多个接口。</p><h3 id="26、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在-try-块中可以抛出异常吗？"><a href="#26、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在-try-块中可以抛出异常吗？" class="headerlink" title="26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try 块中可以抛出异常吗？"></a>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try 块中可以抛出异常吗？</h3><p>考察点：异常<br>回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的 try 语句。</p><h3 id="27、内部类可以引用他包含类的成员吗？有没有什么限制？"><a href="#27、内部类可以引用他包含类的成员吗？有没有什么限制？" class="headerlink" title="27、内部类可以引用他包含类的成员吗？有没有什么限制？"></a>27、内部类可以引用他包含类的成员吗？有没有什么限制？</h3><p>考察点：类<br>回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。</p><h3 id="28、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code-说法是否正确？"><a href="#28、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code-说法是否正确？" class="headerlink" title="28、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code 说法是否正确？"></a>28、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code 说法是否正确？</h3><p>考察点：对象<br>回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><h3 id="29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>考察点：java  重载<br>回答：<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><h3 id="30、如何通过反射获取和设置对象私有字段的值？"><a href="#30、如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="30、如何通过反射获取和设置对象私有字段的值？"></a>30、如何通过反射获取和设置对象私有字段的值？</h3><p>考察点：类<br>回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过 get/set 方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MethodInvokeTest</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>String str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>Method m <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toUpperCase"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HELLO</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="31、谈一下面向对象的”六原则一法则”。"><a href="#31、谈一下面向对象的”六原则一法则”。" class="headerlink" title="31、谈一下面向对象的”六原则一法则”。"></a>31、谈一下面向对象的”六原则一法则”。</h3><p>考察点： Java  对象<br>回答：</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或 Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。</li></ul><h3 id="32、请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#32、请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h3><p>考察点：接口<br>回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</p><h3 id="33、Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#33、Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><p>考察点：方法<br>回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><h3 id="34、Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#34、Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p>考察点： JAVA  构造函数<br>回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</p><h3 id="35、hashCode-和-equals-方法有什么联系？"><a href="#35、hashCode-和-equals-方法有什么联系？" class="headerlink" title="35、hashCode()和 equals()方法有什么联系？"></a>35、hashCode()和 equals()方法有什么联系？</h3><p>考点：基础<br>回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁如果两个对象的 hashCode 相同，它们并不一定相同。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象1</title>
      <link href="/posts/70b0.html"/>
      <url>/posts/70b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、wait-方法底层原理"><a href="#1、wait-方法底层原理" class="headerlink" title="1、wait 方法底层原理"></a>1、wait 方法底层原理</h3><p>考察点：基础<br>回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。</p><h3 id="2、Java-有哪些特性，举个多态的例子。"><a href="#2、Java-有哪些特性，举个多态的例子。" class="headerlink" title="2、Java 有哪些特性，举个多态的例子。"></a>2、Java 有哪些特性，举个多态的例子。</h3><p>考察点：语言特性<br>回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p><h3 id="3、String-为啥不可变？"><a href="#3、String-为啥不可变？" class="headerlink" title="3、String 为啥不可变？"></a>3、String 为啥不可变？</h3><p>考察点：面向对象<br>回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是HashMap 中的键往往都使用字符串的原因。</p><h3 id="4、类和对象的区别"><a href="#4、类和对象的区别" class="headerlink" title="4、类和对象的区别"></a>4、类和对象的区别</h3><p>考察点：面向对象<br>回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。</p><h3 id="5、请列举你所知道的-Object-类的方法。"><a href="#5、请列举你所知道的-Object-类的方法。" class="headerlink" title="5、请列举你所知道的 Object 类的方法。"></a>5、请列举你所知道的 Object 类的方法。</h3><p>考察点：面向对象</p><p>回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p><h3 id="6、重载和重写的区别？相同参数不同返回值能重载吗？"><a href="#6、重载和重写的区别？相同参数不同返回值能重载吗？" class="headerlink" title="6、重载和重写的区别？相同参数不同返回值能重载吗？"></a>6、重载和重写的区别？相同参数不同返回值能重载吗？</h3><p>考察点：重载<br>回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。</p><p>（3）子类函数的访问修饰权限不能少于父类的。</p><h3 id="7、”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#7、”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h3><p>考察点：c static  变量<br>回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</p><h3 id="8、String-能继承吗？"><a href="#8、String-能继承吗？" class="headerlink" title="8、String 能继承吗？"></a>8、String 能继承吗？</h3><p>考察点： String<br>回答：<br>不能，char 数组用 final 修饰的。</p><h3 id="9、StringBuffer-和-StringBuilder-有什么区别，底层实现上呢？"><a href="#9、StringBuffer-和-StringBuilder-有什么区别，底层实现上呢？" class="headerlink" title="9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？"></a>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？</h3><p>考察点：类<br>回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其实就是比 StringBuilder 多了 Synchronized 修饰符。</p><h3 id="10、类加载机制，双亲委派模型，好处是什么？"><a href="#10、类加载机制，双亲委派模型，好处是什么？" class="headerlink" title="10、类加载机制，双亲委派模型，好处是什么？"></a>10、类加载机制，双亲委派模型，好处是什么？</h3><p>考察点：类<br>回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的Java 类，可以正常编译，但是永远无法被加载运行。</p><h3 id="11、静态变量存在哪"><a href="#11、静态变量存在哪" class="headerlink" title="11、静态变量存在哪?"></a>11、静态变量存在哪?</h3><p>考察点：类<br>回答：<br>方法区</p><h3 id="12、讲讲什么是泛型？"><a href="#12、讲讲什么是泛型？" class="headerlink" title="12、讲讲什么是泛型？"></a>12、讲讲什么是泛型？</h3><p>考察点：JAVA  泛型<br>回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*List list = new ArrayList();list.add("qqyumidi");list.add("corn");list.add(100);*/</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"qqyumidi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"corn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//list.add(100); // 1 提示编译错误</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>String name <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>采用泛型写法后，在//1 处想加入一个 Integer 类型的对象时会出现编译错误，通过List<String>，直接限定了 list 集合中只能含有 String 类型的元素，从而在//2 处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型了。</p><h3 id="13、解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#13、解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="13、解释 extends 和 super 泛型限定符-上界不存下界不取"></a>13、解释 extends 和 super 泛型限定符-上界不存下界不取</h3><p>考察点：JAVA  泛型<br>回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Jonathan</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CovariantArrays</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//上界</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token operator">></span> flistTop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistTop<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//add Fruit 对象会报错</span><span class="token comment" spellcheck="true">//flist.add(new Fruit());</span>Fruit fruit1 <span class="token operator">=</span> flistTop<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下界</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Apple<span class="token operator">></span> flistBottem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistBottem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistBottem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jonathan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//get Apple 对象会报错</span><span class="token comment" spellcheck="true">//Apple apple = flistBottem.get(0);</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</p><p>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</p><h3 id="14、是否可以在-static-环境中访问非-static-变量？"><a href="#14、是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="14、是否可以在 static 环境中访问非 static 变量？"></a>14、是否可以在 static 环境中访问非 static 变量？</h3><p>考察点： static  变量<br>回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h3 id="15、谈谈如何通过反射创建对象？"><a href="#15、谈谈如何通过反射创建对象？" class="headerlink" title="15、谈谈如何通过反射创建对象？"></a>15、谈谈如何通过反射创建对象？</h3><p>考察点：类<br>回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);</li></ul><h3 id="16、Java-支持多继承么？"><a href="#16、Java-支持多继承么？" class="headerlink" title="16、Java 支持多继承么？"></a>16、Java 支持多继承么？</h3><p>考察点： JAVA  多继承<br>回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h3 id="17、接口和抽象类的区别是什么？"><a href="#17、接口和抽象类的区别是什么？" class="headerlink" title="17、接口和抽象类的区别是什么？"></a>17、接口和抽象类的区别是什么？</h3><p>考察点：抽象类<br>回答：<br>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p><p>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。<br>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。<br>也可以参考 JDK8 中抽象类和接口的区别</p><h3 id="18、Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#18、Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。</h3><p>考察点：comparable  接口<br>回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回true。</p><h3 id="19、面向对象的特征有哪些方面"><a href="#19、面向对象的特征有哪些方面" class="headerlink" title="19、面向对象的特征有哪些方面"></a>19、面向对象的特征有哪些方面</h3><p>考察点： JAVA  特征<br>回答：<br>(1)抽象：<br>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br>(2)继承：<br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原<br>始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br>(3)封装：<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br>(4) 多态性：<br>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p><h3 id="20、final-finally-finalize-的区别。"><a href="#20、final-finally-finalize-的区别。" class="headerlink" title="20、final, finally, finalize 的区别。"></a>20、final, finally, finalize 的区别。</h3><p>考察点：声明<br>回答：<br>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>finally 是异常处理语句结构的一部分，表示总是执行。<br>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/posts/beea.html"/>
      <url>/posts/beea.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、介绍一下-Syncronized-锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#1、介绍一下-Syncronized-锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h3><p>考点：java  关键字<br>回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。</p><h3 id="2、介绍一下-volatile？"><a href="#2、介绍一下-volatile？" class="headerlink" title="2、介绍一下 volatile？"></a>2、介绍一下 volatile？</h3><p>考察点：java  关键字<br>回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。</p><h3 id="3、锁有了解嘛，说一下-Synchronized-和-lock"><a href="#3、锁有了解嘛，说一下-Synchronized-和-lock" class="headerlink" title="3、锁有了解嘛，说一下 Synchronized 和 lock"></a>3、锁有了解嘛，说一下 Synchronized 和 lock</h3><p>考察点：java  关键字</p><p>回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h3 id="4、讲一讲-Java-里面的-final-关键字怎么用的？"><a href="#4、讲一讲-Java-里面的-final-关键字怎么用的？" class="headerlink" title="4、讲一讲 Java 里面的 final 关键字怎么用的？"></a>4、讲一讲 Java 里面的 final 关键字怎么用的？</h3><p>考察点：关键字<br>回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础部分3</title>
      <link href="/posts/2ce6.html"/>
      <url>/posts/2ce6.html</url>
      
        <content type="html"><![CDATA[<h3 id="21、你能比较一下-Java-和-JavaSciprt-吗？"><a href="#21、你能比较一下-Java-和-JavaSciprt-吗？" class="headerlink" title="21、你能比较一下 Java 和 JavaSciprt 吗？"></a>21、你能比较一下 Java 和 JavaSciprt 吗？</h3><p>考察： Java&amp;JavaScript<br>回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</p><ul><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型</li><li>代码格式不一样。</li></ul><h3 id="22、简述正则表达式及其用途。"><a href="#22、简述正则表达式及其用途。" class="headerlink" title="22、简述正则表达式及其用途。"></a>22、简述正则表达式及其用途。</h3><p>考察点：正则表达式<br>回答：</p><p>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。</p><h3 id="23、Java-中是如何支持正则表达式操作的？"><a href="#23、Java-中是如何支持正则表达式操作的？" class="headerlink" title="23、Java 中是如何支持正则表达式操作的？"></a>23、Java 中是如何支持正则表达式操作的？</h3><p>考察点：正则表达式<br>回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Matcher<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Pattern<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">RegExpTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"成都市(成华区)(武侯区)(高新区)"</span><span class="token punctuation">;</span>        Pattern p <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">".*?(?=\\()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Matcher m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="24、请你说说-Java-和-PHP-的区别？"><a href="#24、请你说说-Java-和-PHP-的区别？" class="headerlink" title="24、请你说说 Java 和 PHP 的区别？"></a>24、请你说说 Java 和 PHP 的区别？</h3><p>考察点：Java  特性<br>回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件.第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT分支也正在开发测试中.在 php-src/Zend/bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk/jre/lib/rt.jar,大于 60MB)用 Java 编写(jdk/src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模板引擎.</p><p>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM/HHVM/Apache 实现.PHP-FPM进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 关键字 </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础部分2</title>
      <link href="/posts/ec27.html"/>
      <url>/posts/ec27.html</url>
      
        <content type="html"><![CDATA[<h3 id="11、什么是值传递和引用传递？"><a href="#11、什么是值传递和引用传递？" class="headerlink" title="11、什么是值传递和引用传递？"></a>11、什么是值传递和引用传递？</h3><p>考察点：JAVA  引用传递<br>回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身。所以对引用对象进行操作会同时改变原对象。一般认为,Java 内的传递都是值传递。</p><h3 id="12、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#12、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h3><p>考察点：Array</p><p>回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="13、你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#13、你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h3><p>考察点：JAVA  notation<br>回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;=c*g(n),则 f(n)=O(g(n));大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</p><h3 id="14、String-是最基本的数据类型吗"><a href="#14、String-是最基本的数据类型吗" class="headerlink" title="14、String 是最基本的数据类型吗?"></a>14、String 是最基本的数据类型吗?</h3><p>考察点：数据类型<br>回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用 StringBuffer 类</p><h3 id="15、int-和-Integer-有什么区别？"><a href="#15、int-和-Integer-有什么区别？" class="headerlink" title="15、int 和 Integer 有什么区别？"></a>15、int 和 Integer 有什么区别？</h3><p>考察点：数据类型</p><p>回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p><h3 id="16、String-和-StringBuffer-的区别？"><a href="#16、String-和-StringBuffer-的区别？" class="headerlink" title="16、String 和 StringBuffer 的区别？"></a>16、String 和 StringBuffer 的区别？</h3><p>考察点：数据类型<br>回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer。典型地，你可以使用 StringBuffers 来动态构造字符数据。</p><h3 id="17、我们在-web-应用开发过程中经常遇到输出某种编码的字符，如-iso8859-1等，如何输出一个某种编码的字符串？"><a href="#17、我们在-web-应用开发过程中经常遇到输出某种编码的字符，如-iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1等，如何输出一个某种编码的字符串？"></a>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1等，如何输出一个某种编码的字符串？</h3><p>考察点：数据类型</p><p>回答：</p><pre class=" language-java"><code class="language-java">Public String <span class="token function">translate</span> <span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>String tempStr <span class="token operator">=</span> “”<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>tempStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>“ISO<span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span>″<span class="token punctuation">)</span><span class="token punctuation">,</span> “GBK”<span class="token punctuation">)</span><span class="token punctuation">;</span>tempStr <span class="token operator">=</span> tempStr<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> tempStr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="18、int-和-Integer-有什么区别？"><a href="#18、int-和-Integer-有什么区别？" class="headerlink" title="18、int 和 Integer 有什么区别？"></a>18、int 和 Integer 有什么区别？</h3><p>考察点：数据类型<br>回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><p>如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AutoUnboxingTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 3 自动装箱成 Integer 类型</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false 两个引用没有引用同一对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true a 自动拆箱成 int 类型再和 c 比较</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="19、-amp-和-amp-amp-的区别"><a href="#19、-amp-和-amp-amp-的区别" class="headerlink" title="19、&amp;和&amp;&amp;的区别?"></a>19、&amp;和&amp;&amp;的区别?</h3><p>考察点：运算符<br>回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals 比较，否则会产生 NullPointerException 异常。</p><h3 id="20、在-Java-中，如何跳出当前的多重嵌套循环？"><a href="#20、在-Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="20、在 Java 中，如何跳出当前的多重嵌套循环？"></a>20、在 Java 中，如何跳出当前的多重嵌套循环？</h3><p>考察点：循环<br>回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C和 C++中的 goto 语句，但是就像要避免使用 goto一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p><blockquote><p>本文参考Java面试题库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础部分1</title>
      <link href="/posts/a65c.html"/>
      <url>/posts/a65c.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法-Javat特性"><a href="#基本语法-Javat特性" class="headerlink" title="基本语法   Javat特性"></a>基本语法   Javat特性</h2><h3 id="1、为什么重写-equals-还要重写-hashcode？"><a href="#1、为什么重写-equals-还要重写-hashcode？" class="headerlink" title="1、为什么重写 equals 还要重写 hashcode？"></a>1、为什么重写 equals 还要重写 hashcode？</h3><p>考点：Java基础</p><p>回答：</p><p>​        HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。                                    HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对应的这个键值对。</p><h3 id="2、说一下-map-的分类和常见的情况"><a href="#2、说一下-map-的分类和常见的情况" class="headerlink" title="2、说一下 map 的分类和常见的情况"></a>2、说一下 map 的分类和常见的情况</h3><p>考点：java 基础<br>回答：<br>        java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMapHashtable LinkedHashMap 和 TreeMap.<br>        Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。<br>        Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>        Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p>​        LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。<br>​        TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>​        一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>​        HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>​        HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的能力。<br>​        Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>​        LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。<br>​        在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p><h3 id="3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h3><p>考点：基础<br>回答：<br>        Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</p><h3 id="4、-比较的是什么？"><a href="#4、-比较的是什么？" class="headerlink" title="4、==比较的是什么？"></a>4、==比较的是什么？</h3><p>考点：基础<br>回答：<br>        “==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回 true，否则返回 false。“==”如果两边是基本类型，就是比较数值是否相等。</p><h3 id="5、若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#5、若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="5、若对一个类不重写，它的 equals()方法是如何比较的？"></a>5、若对一个类不重写，它的 equals()方法是如何比较的？</h3><p>考点：基础<br>回答：<br>        比较是对象的地址。</p><h3 id="6、java8-新特性"><a href="#6、java8-新特性" class="headerlink" title="6、java8 新特性"></a>6、java8 新特性</h3><p>考察点： java8<br>回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用</p><h3 id="7、说说-Lamda-表达式的优缺点"><a href="#7、说说-Lamda-表达式的优缺点" class="headerlink" title="7、说说 Lamda 表达式的优缺点"></a>7、说说 Lamda 表达式的优缺点</h3><p>考察点：a Java  基础<br>回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><h3 id="8、一个十进制的数在内存中是怎么存的？"><a href="#8、一个十进制的数在内存中是怎么存的？" class="headerlink" title="8、一个十进制的数在内存中是怎么存的？"></a>8、一个十进制的数在内存中是怎么存的？</h3><p>考察点：计算机基础</p><p>回答：<br>补码的形式。</p><h3 id="9、为啥有时会出现-4-0-3-6-0-40000001-这种现象"><a href="#9、为啥有时会出现-4-0-3-6-0-40000001-这种现象" class="headerlink" title="9、为啥有时会出现 4.0-3.6=0.40000001 这种现象"></a>9、为啥有时会出现 4.0-3.6=0.40000001 这种现象</h3><p>考察点：计算机基础</p><p>回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</p><h3 id="10、Java-支持的数据类型有哪些？什么是自动拆装箱？"><a href="#10、Java-支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="10、Java 支持的数据类型有哪些？什么是自动拆装箱？"></a>10、Java 支持的数据类型有哪些？什么是自动拆装箱？</h3><p>考察点：A JAVA  数据类型<br>回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。</p><blockquote><p>本文参考Java面试题库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
