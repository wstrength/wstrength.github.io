<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面试基础部分2</title>
      <link href="/posts/ec27.html"/>
      <url>/posts/ec27.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面试基础部分1</title>
      <link href="/posts/a65c.html"/>
      <url>/posts/a65c.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、为什么重写-equals-还要重写-hashcode？"><a href="#1、为什么重写-equals-还要重写-hashcode？" class="headerlink" title="1、为什么重写 equals 还要重写 hashcode？"></a>1、为什么重写 equals 还要重写 hashcode？</h3><p>考点：Java基础</p><p>回答：</p><p>​        HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。                                    HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对应的这个键值对。</p><h3 id="2、说一下-map-的分类和常见的情况"><a href="#2、说一下-map-的分类和常见的情况" class="headerlink" title="2、说一下 map 的分类和常见的情况"></a>2、说一下 map 的分类和常见的情况</h3><p>考点：java 基础<br>回答：<br>        java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMapHashtable LinkedHashMap 和 TreeMap.<br>        Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。<br>        Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>        Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p>​        LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。<br>​        TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>​        一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>​        HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>​        HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的能力。<br>​        Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>​        LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。<br>​        在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p><h3 id="3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h3><p>考点：基础<br>回答：<br>        Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</p><h3 id="4、-比较的是什么？"><a href="#4、-比较的是什么？" class="headerlink" title="4、==比较的是什么？"></a>4、==比较的是什么？</h3><p>考点：基础<br>回答：<br>        “==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回 true，否则返回 false。“==”如果两边是基本类型，就是比较数值是否相等。</p><h3 id="5、若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#5、若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="5、若对一个类不重写，它的 equals()方法是如何比较的？"></a>5、若对一个类不重写，它的 equals()方法是如何比较的？</h3><p>考点：基础<br>回答：<br>        比较是对象的地址。</p><h3 id="6、java8-新特性"><a href="#6、java8-新特性" class="headerlink" title="6、java8 新特性"></a>6、java8 新特性</h3><p>考察点： java8<br>回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用</p><h3 id="7、说说-Lamda-表达式的优缺点"><a href="#7、说说-Lamda-表达式的优缺点" class="headerlink" title="7、说说 Lamda 表达式的优缺点"></a>7、说说 Lamda 表达式的优缺点</h3><p>考察点：a Java  基础<br>回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><h3 id="8、一个十进制的数在内存中是怎么存的？"><a href="#8、一个十进制的数在内存中是怎么存的？" class="headerlink" title="8、一个十进制的数在内存中是怎么存的？"></a>8、一个十进制的数在内存中是怎么存的？</h3><p>考察点：计算机基础</p><p>回答：<br>补码的形式。</p><h3 id="9、为啥有时会出现-4-0-3-6-0-40000001-这种现象"><a href="#9、为啥有时会出现-4-0-3-6-0-40000001-这种现象" class="headerlink" title="9、为啥有时会出现 4.0-3.6=0.40000001 这种现象"></a>9、为啥有时会出现 4.0-3.6=0.40000001 这种现象</h3><p>考察点：计算机基础</p><p>回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</p><h3 id="10、Java-支持的数据类型有哪些？什么是自动拆装箱？"><a href="#10、Java-支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="10、Java 支持的数据类型有哪些？什么是自动拆装箱？"></a>10、Java 支持的数据类型有哪些？什么是自动拆装箱？</h3><p>考察点：A JAVA  数据类型<br>回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。</p><blockquote><p>本文参考Java面试题库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
