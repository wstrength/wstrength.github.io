<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络2</title>
      <link href="/posts/eb71.html"/>
      <url>/posts/eb71.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、arp-协议，arp-攻击"><a href="#1、arp-协议，arp-攻击" class="headerlink" title="1、arp 协议，arp 攻击"></a>1、arp 协议，arp 攻击</h3><p>考察点： ARP  协议<br>回答：<br>地址解析协议。ARP 攻击的第一步就是 ARP 欺骗。由上述“ARP 协议的工作过程”我们知道，ARP 协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP 协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现 ARP 应答中的 IP 地址和 MAC地址中的信息是可以伪造的，并不一定是自己的真实 IP 地址和 MAC 地址，由此，ARP 欺骗就产生了。</p><h3 id="2、网际控制报文协议-ICMP协议"><a href="#2、网际控制报文协议-ICMP协议" class="headerlink" title="2、网际控制报文协议 ICMP协议"></a>2、网际控制报文协议 ICMP协议</h3><p>考察点： ICMP  协议<br>回答：<br>它是 TCP/IP 协议族的一个子协议，用于在 IP 主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><h3 id="3、讲一下路由器和交换机的区别？"><a href="#3、讲一下路由器和交换机的区别？" class="headerlink" title="3、讲一下路由器和交换机的区别？"></a>3、讲一下路由器和交换机的区别？</h3><p>考察点：路由器<br>回答：<br>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修数据帧工作在 TCP/IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和需要重新计算，数据帧需要重新封装工作在 TCP/IP 协议的三层 —— 网络层工作复杂，使用软件处理。</p><h3 id="4、DNS-寻址过程"><a href="#4、DNS-寻址过程" class="headerlink" title="4、DNS 寻址过程"></a>4、DNS 寻址过程</h3><p>考察点：DNS</p><p>回答：<br>1、在浏览器中输入 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。<br>2、如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射<br>关系，如果有，直接返回，完成域名解析。<br>3、如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/ip 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。<br>4、如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。<br>5、如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是<br>否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的<br>一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责.com 域的这台服务器。这台负责.com<br>域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com 域的下一级 DNS 服务器地<br>址(qq.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服器，<br>重复上面的动作，进行查询，直至找到 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 主机。<br>6、如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此DNS 服务器再返回给客户机。</p><p>从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查询。</p><h3 id="5、负载均衡反向代理模式优点及缺点"><a href="#5、负载均衡反向代理模式优点及缺点" class="headerlink" title="5、负载均衡反向代理模式优点及缺点"></a>5、负载均衡反向代理模式优点及缺点</h3><p>考察点：反向代理<br>回答：<br>（1）反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>（2）反向代理负载均衡技术是把将来自 internet 上的连接请求以反向代理的方式动态地转发给内部网络上的多台服务器进行处理，从而达到负载均衡的目的。<br>（3）反向代理负载均衡能以软件方式来实现，如 apache mod_proxy、netscape proxy 等，也可以在高速缓存器、负载均衡器等硬件设备上实现。反向代理负载均衡可以将优化的负载均衡策略和代理服务器的高速缓存技术结合在一起，提升静态网页的访问速度，提供有益的性能；由于网络外部用户不能直接访问真实的服务器，具备额外的安全性（同理，NAT 负载均衡技术也有此点）。</p><p>（4）其缺点主要表现在以下两个方面<br>反向代理是处于 OSI 参考模型第七层应用的，所以就必须为每一种应用服务专门开发一个反向代理服务器，这样就限制了反向代理负载均衡技术的应用范围，现在一般都用于对 web 服务器的负载均衡。<br>针对每一次代理，代理服务器就必须打开两个连接，一个对外，一个对内，因此在并发连接请求数量非常大的时候，代理服务器的负载也就非常大了，在最后代理服务器本身会成为服务的瓶颈。<br>一般来讲，可以用它来对连接数量不是特别大，但每次连接都需要消耗大量处理资源的站点进行负载均衡，如 search 等。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络1</title>
      <link href="/posts/ea31.html"/>
      <url>/posts/ea31.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、网络概述"><a href="#一、网络概述" class="headerlink" title="一、网络概述"></a>一、网络概述</h2><h3 id="1、TCP-协议在哪一层？IP-协议在那一层？HTTP-在哪一层？"><a href="#1、TCP-协议在哪一层？IP-协议在那一层？HTTP-在哪一层？" class="headerlink" title="1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？"></a>1、TCP 协议在哪一层？IP 协议在那一层？HTTP 在哪一层？</h3><p>考察点：网络七层模型<br>回答：<br>运输层，网络层，应用层。</p><h2 id="二、运输层"><a href="#二、运输层" class="headerlink" title="二、运输层"></a>二、运输层</h2><h3 id="1、讲一下-TCP-的连接和释放连接。"><a href="#1、讲一下-TCP-的连接和释放连接。" class="headerlink" title="1、讲一下 TCP 的连接和释放连接。"></a>1、讲一下 TCP 的连接和释放连接。</h3><p>考察点：网络基础<br>回答：<br>三次握手的过程<br>1）主机 A 向主机 B 发送 TCP 连接请求数据包，其中包含主机 A 的初始序列号 seq(A)=x。（其中报文中同步标志位 SYN=1，ACK=0，表示这是一个 TCP 连接请求数据报文；序号 seq=x，表明传<br>输数据时的第一个数据字节的序号是 x）；<br>2）主机 B 收到请求后，会发回连接确认数据包。（其中确认报文段中，标识位 SYN=1，ACK=1，<br>表示这是一个 TCP 连接响应数据报文，并含主机 B 的初始序列号 seq(B)=y，以及主机 B 对主机 A<br>初始序列号的确认号 ack(B)=seq(A)+1=x+1）<br>3）第三次，主机 A 收到主机 B 的确认报文后，还需作出确认，即发送一个序列号 seq(A)=x+1；确认号为 ack(A)=y+1 的报文；<br>四次挥手过程</p><p>假设主机 A 为客户端，主机 B 为服务器，其释放 TCP 连接的过程如下：<br>1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u。<br>2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。<br>3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。<br>4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加1。 首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p><img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="三次握手"></p><p><img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><h3 id="2、TCP-有哪些应用场景"><a href="#2、TCP-有哪些应用场景" class="headerlink" title="2、TCP 有哪些应用场景"></a>2、TCP 有哪些应用场景</h3><p>考察点： TCP  协议<br>回答：</p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议</p><h3 id="3、tcp-为什么可靠"><a href="#3、tcp-为什么可靠" class="headerlink" title="3、tcp 为什么可靠"></a>3、tcp 为什么可靠</h3><p>考察点： TCP<br>回答：<br>三次握手，超时重传，滑动窗口，拥塞控制。</p><h3 id="4、tcp-为什么要建立连接"><a href="#4、tcp-为什么要建立连接" class="headerlink" title="4、tcp 为什么要建立连接"></a>4、tcp 为什么要建立连接</h3><p>考察点： TCP<br>回答：<br>保证可靠传输。</p><h3 id="5、阐述-TCP-的-4-次挥手"><a href="#5、阐述-TCP-的-4-次挥手" class="headerlink" title="5、阐述 TCP 的 4 次挥手"></a>5、阐述 TCP 的 4 次挥手</h3><p>考察点：TCP  协议<br>回答：<br>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close()操作即可产生挥手操作。<br>（1）客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。<br>（2）服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。<br>（3）服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。<br>（4）客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。</p><p><img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP四次挥手"></p><h3 id="6、讲一下浏览器从接收到一个-URL-到最后展示出页面，经历了哪些过程。tag"><a href="#6、讲一下浏览器从接收到一个-URL-到最后展示出页面，经历了哪些过程。tag" class="headerlink" title="6、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag"></a>6、讲一下浏览器从接收到一个 URL 到最后展示出页面，经历了哪些过程。tag</h3><p>考察点： http  协议<br>回答：<br>1.DNS 解析 2.TCP 连接 3.发送 HTTP 请求 4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面</p><h3 id="7、http-和-https-的区别"><a href="#7、http-和-https-的区别" class="headerlink" title="7、http 和 https 的区别"></a>7、http 和 https 的区别</h3><p>考察点：http  协议<br>回答；<br>https 协议要申请证书到 ca，需要一定经济成本；2） http 是明文传输，https 是加密的安全传输；3） 连接的端口不一样，http 是 80，https 是 443；4）http 连接很简单，没有状态；https 是 ssl 加密的传输，身份认证的网络协议，相对 http 传输比较安全。</p><h3 id="8、http-的请求有哪些，应答码-502-和-504-有什么区别"><a href="#8、http-的请求有哪些，应答码-502-和-504-有什么区别" class="headerlink" title="8、http 的请求有哪些，应答码 502 和 504 有什么区别"></a>8、http 的请求有哪些，应答码 502 和 504 有什么区别</h3><p>考察点：http  协议<br>回答：<br>OPTIONS：返回服务器针对特定资源所支持的 HTTP 请求方法。也可以利用向 Web 服务器发送’*’的请求来测试服务器的功能性。<br>HEAD：向服务器索要与 GET 请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p><p>GET：向特定的资源发出请求。<br>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的创建和/或已有资源的修改。<br>PUT：向指定资源位置上传其最新内容。<br>DELETE：请求服务器删除 Request-URI 所标识的资源。<br>TRACE：回显服务器收到的请求，主要用于测试或诊断。<br>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。<br>虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。<br>502：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>504：作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI 标识出的服务器，例如 HTTP、FTP、LDAP）或者辅助服务器（例如 DNS）收到响应。</p><h3 id="9、http1-1-和-1-0-的区别"><a href="#9、http1-1-和-1-0-的区别" class="headerlink" title="9、http1.1 和 1.0 的区别"></a>9、http1.1 和 1.0 的区别</h3><p>考察点： http<br>回答：<br>主要区别主要体现在：<br>缓存处理，在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since,If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。<br>带宽优化及网络连接的使用，HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），<br>这样就方便了开发者自由的选择以便于充分利用带宽和连接。<br>错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。<br>Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad<br>Request）。<br>长连接，HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p><h3 id="10、说说-ssl-四次握手的过程"><a href="#10、说说-ssl-四次握手的过程" class="headerlink" title="10、说说 ssl 四次握手的过程"></a>10、说说 ssl 四次握手的过程</h3><p>考察：HTTP  加密协议<br>回答：<br>1、 客户端发出请求<br>首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做 ClientHello请求。<br>2、服务器回应<br>服务器收到客户端请求后，向客户端发出回应，这叫做 SeverHello。<br>3、客户端回应<br>客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>4、服务器的最后回应<br>服务器收到客户端的第三个随机数 pre-master key 之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。<br>（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。<br>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的 hash 值，用来供客户端校验。<br>至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用”会话密钥”加密内容。</p><h3 id="11、304-状态码有什么含义？"><a href="#11、304-状态码有什么含义？" class="headerlink" title="11、304 状态码有什么含义？"></a>11、304 状态码有什么含义？</h3><p>考察点： http<br>回答：<br>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 概述 </tag>
            
            <tag> 运输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统2</title>
      <link href="/posts/3c4.html"/>
      <url>/posts/3c4.html</url>
      
        <content type="html"><![CDATA[<h2 id="三、输入输出系统"><a href="#三、输入输出系统" class="headerlink" title="三、输入输出系统"></a>三、输入输出系统</h2><h3 id="1、socket-编程，BIO，NIO，epoll？"><a href="#1、socket-编程，BIO，NIO，epoll？" class="headerlink" title="1、socket 编程，BIO，NIO，epoll？"></a>1、socket 编程，BIO，NIO，epoll？</h3><p>考察点：O I/O  多路复用<br>回答：<br>阻塞，非阻塞，io 多路复用，epoll 支持文件符数目没有限制，fd 集合只会从用户进程拷贝到内核一次，自己维护一个事件队列，不用每次遍历 fd 集合发现是否有就绪状态。</p><h2 id="四、存储器管理"><a href="#四、存储器管理" class="headerlink" title="四、存储器管理"></a>四、存储器管理</h2><h3 id="1、什么是页式存储？"><a href="#1、什么是页式存储？" class="headerlink" title="1、什么是页式存储？"></a>1、什么是页式存储？</h3><p>考察点：页式存储<br>回答：<br>主存被等分成大小相等的片，称为主存块，又称为实页。<br>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为 2n ,通常为 1KB、2KB、<br>2n KB 等</p><h3 id="2、操作系统里的内存碎片你怎么理解，有什么解决办法？"><a href="#2、操作系统里的内存碎片你怎么理解，有什么解决办法？" class="headerlink" title="2、操作系统里的内存碎片你怎么理解，有什么解决办法？"></a>2、操作系统里的内存碎片你怎么理解，有什么解决办法？</h3><p>考察点：内存碎片<br>回答：<br>内存碎片分为：内部碎片和外部碎片。<br>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；<br>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才<br>有可能利用这个存储块。</p><p>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。<br>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。<br>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。</p><p>使用伙伴系统算法。</p><h2 id="五、处理机调度与死锁"><a href="#五、处理机调度与死锁" class="headerlink" title="五、处理机调度与死锁"></a>五、处理机调度与死锁</h2><h3 id="1、什么情况下会发生死锁，解决策略有哪些？"><a href="#1、什么情况下会发生死锁，解决策略有哪些？" class="headerlink" title="1、什么情况下会发生死锁，解决策略有哪些？"></a>1、什么情况下会发生死锁，解决策略有哪些？</h3><p>考察点：死锁<br>回答：<br>（一）互斥条件：一个资源一次只能被一个进程访问。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或两个以上的进程占 有。这种独占资源如 CD-ROM 驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属<br>性所决定的。<br>（二）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。进程至少已经占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占用已占有的资源。<br>（三）不剥夺条件：进程已经获得的资源，在未使用完之前不能强行剥夺，而只能由该资源的占有者进程自行释放。<br>（四）循环等待条件：若干资源形成一种头尾相接的循环等待资源关系。<br>解决方法：银行家算法</p><h3 id="2、系统-CPU-比较高是什么原因？"><a href="#2、系统-CPU-比较高是什么原因？" class="headerlink" title="2、系统 CPU 比较高是什么原因？"></a>2、系统 CPU 比较高是什么原因？</h3><p>考察点：处理机<br>回答：<br>1、首先查看是哪些进程的 CPU 占用率最高（如下可以看到详细的路径）<br>ps -aux –sort -pcpu | more</p><p>定位有问题的线程可以用如下命令</p><p>ps -mp pid -o THREAD,tid,time | more<br>2、查看 JAVA 进程的每个线程的 CPU 占用率<br>ps -Lp 5798 cu | more # 5798 是查出来进程 PID</p><p>3、追踪线程，查看负载过高的原因，使用 JDK 下的一个工具<br>jstack 5798 # 5798 是 PID<br>jstack -J-d64 -m 5798 # -j-d64 指定 64 为系统<br>jstack 查出来的线程 ID 是 16 进制，可以把输出追加到文件，导出用记事本打开，再根据<br>系统中的线程 ID 去搜索查看该 ID 的线程运行内容，可以和开发一起排查。</p><h3 id="3、系统如何提高并发性？"><a href="#3、系统如何提高并发性？" class="headerlink" title="3、系统如何提高并发性？"></a>3、系统如何提高并发性？</h3><p>考察：操作系统综合性<br>回答：<br>1、提高 CPU 并发计算能力<br>（1）多进程&amp;多线程<br>（2）减少进程切换，使用线程，考虑进程绑定 CPU<br>（3）减少使用不必要的锁，考虑无锁编程<br>（4）考虑进程优先级<br>（5）关注系统负载<br>2、改进 I/O 模型<br>(1)DMA 技术<br>(2)异步 I/O<br>(3)改进多路 I/O 就绪通知策略，epoll<br>(4)Sendfile<br>(5)内存映射<br>(6)直接 I/O</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入输出 </tag>
            
            <tag> 存储器管理 </tag>
            
            <tag> 处理机调度与死锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统1</title>
      <link href="/posts/284.html"/>
      <url>/posts/284.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-、-操作系统概论"><a href="#一-、-操作系统概论" class="headerlink" title="一 、 操作系统概论"></a>一 、 操作系统概论</h2><h3 id="1、CentOS-和-Linux-的关系？"><a href="#1、CentOS-和-Linux-的关系？" class="headerlink" title="1、CentOS 和 Linux 的关系？"></a>1、CentOS 和 Linux 的关系？</h3><p>考察点：操作系统<br>回答：<br>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）,<br>而 Redhat 有收费的商业版和免费的开源版,商业版的业内称之为 RHEL 系列，CentOS 是来自于依<br>照开放源代码规定而公布的源代码重新编译而成。可以用 CentOS 替代商业版的 RHEL 使用。两者<br>的不同，CentOS 不包含封闭源代码软件，是免费的。</p><h3 id="2、64-位和-32-位的区别？"><a href="#2、64-位和-32-位的区别？" class="headerlink" title="2、64 位和 32 位的区别？"></a>2、64 位和 32 位的区别？</h3><p>考察点：<br>操作系统<br>回答：<br>操作系统只是硬件和应用软件中间的一个平台。32 位操作系统针对的 32 位的 CPU 设计。64<br>位操作系统针对的 64 位的 CPU 设计。</p><h2 id="二、进程的描述与控制"><a href="#二、进程的描述与控制" class="headerlink" title="二、进程的描述与控制"></a>二、进程的描述与控制</h2><h3 id="1、怎么杀死进程？"><a href="#1、怎么杀死进程？" class="headerlink" title="1、怎么杀死进程？"></a>1、怎么杀死进程？</h3><p>考察点：进程<br>回答：</p><p>Kill pid</p><h3 id="2、线程，进程区别"><a href="#2、线程，进程区别" class="headerlink" title="2、线程，进程区别"></a>2、线程，进程区别</h3><p>考察点：进程，线程<br>回答：<br>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.<br>2) 线程的划分尺度小于进程，使得多线程程序的并发性高。<br>3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高<br>了程序的运行效率。<br>4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</p><h3 id="3、系统线程数量上限是多少？"><a href="#3、系统线程数量上限是多少？" class="headerlink" title="3、系统线程数量上限是多少？"></a>3、系统线程数量上限是多少？</h3><p>考察点：线程<br>回答：<br>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。这个限制可以在/usr/include/bits/local_lim.h 中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。<br>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是 8M=8192KB。</p><h3 id="4、进程和线程的区别是什么？"><a href="#4、进程和线程的区别是什么？" class="headerlink" title="4、进程和线程的区别是什么？"></a>4、进程和线程的区别是什么？</h3><p>考察点：JAVA  进程<br>参考回答：<br>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><h3 id="5、解释一下-LINUX-下线程，GDI-类。"><a href="#5、解释一下-LINUX-下线程，GDI-类。" class="headerlink" title="5、解释一下 LINUX 下线程，GDI 类。"></a>5、解释一下 LINUX 下线程，GDI 类。</h3><p>考察点：线程<br>参考回答：<br>LINUX 实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。<br>GDI 类为图像设备编程接口类库。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 概论 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JVM</title>
      <link href="/posts/9497.html"/>
      <url>/posts/9497.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、JVM-回收算法和回收器，CMS-采用哪种回收算法，怎么解决内存碎片问题？"><a href="#1、JVM-回收算法和回收器，CMS-采用哪种回收算法，怎么解决内存碎片问题？" class="headerlink" title="1、JVM 回收算法和回收器，CMS 采用哪种回收算法，怎么解决内存碎片问题？"></a>1、JVM 回收算法和回收器，CMS 采用哪种回收算法，怎么解决内存碎片问题？</h3><p>考察点： JVM<br>回答：<br>垃圾回收算法<br>标记清除<br>标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段首先通过根节点，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法带来的一个问题是会存在大量的空间碎片，因为回收后的空间是不连续的，这样给大对象分配内存的时候可能会提前触发 full gc。<br>复制算法</p><p>将现有的内存空间分为两快，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。<br>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 研究表明新生代中的对象 98%是朝夕生死的，所以并不需要按照 1:1 的比例划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中的一块 Survivor。当回收时，将 Eden 和Survivor 中还存活着的对象一次性地拷贝到另外一个 Survivor 空间上，最后清理掉 Eden 和刚<br>才用过的 Survivor 的空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8:1(可以通过<br>-SurvivorRattio 来配置)，也就是每次新生代中可用内存空间为整个新生代容量的 90%，只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证回<br>收都只有不多于 10%的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年<br>代）进行分配担保。<br>标记整理<br>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。<br>标记-压缩算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。首先也需要从根节点开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。<br>增量算法<br>增量算法的基本思想是，如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。<br>垃圾回收器<br>Serial 收集器<br>Serial 收集器是最古老的收集器，它的缺点是当 Serial 收集器想进行垃圾回收的时候，必须暂停用户的所有进程，即 stop the world。到现在为止，它依然是虚拟机运行在 client 模式下的默认新生代收集器，与其他收集器相比，对于限定在单个 CPU 的运行环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾回收自然可以获得最高的单线程收集效率。<br>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用”标记－整理“算法。这个收集器的主要意义也是被 Client 模式下的虚拟机使用。在 Server 模式下，它主要还有两大用途：一个是在 JDK1.5 及以前的版本中与 Parallel Scanvenge 收集器搭配使用，另外一个就是作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 的时候使用。<br>通过指定-UseSerialGC 参数，使用 Serial + Serial Old 的串行收集器组合进行内存回收。<br>ParNew 收集器</p><p>ParNew 收集器是 Serial 收集器新生代的多线程实现，注意在进行垃圾回收的时候依然会stop the world，只是相比较 Serial 收集器而言它会运行多条进程进行垃圾回收。<br>ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个 CPU 的环境中都不能百分之百的保证能超越 Serial 收集器。当然，随着可以使用的 CPU 的数量增加，它对于 GC 时系统资源的利用还是很有好处的。它默认开启的收集线程数与 CPU 的数量相同，在 CPU 非常多（譬如 32 个，现在 CPU<br>动辄 4 核加超线程，服务器超过 32 个逻辑 CPU 的情况越来越多了）的环境下，可以使用<br>-XX:ParallelGCThreads 参数来限制垃圾收集的线程数。<br>-UseParNewGC: 打开此开关后，使用 ParNew + Serial Old 的收集器组合进行内存回收，这样新生代使用并行收集器，老年代使用串行收集器。<br>Parallel Scavenge 收集器<br>Parallel 是采用复制算法的多线程新生代垃圾回收器，似乎和 ParNew 收集器有很多的相似的地方。但是 Parallel Scanvenge 收集器的一个特点是它所关注的目标是吞吐量(Throughput)。<br>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量=运行用户代<br>码时间 / (运行用户代码时间 + 垃圾收集时间)。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能够提升用户的体验；而高吞吐量则可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。<br>Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，采用多线程和”标记－整理”算法。这个收集器是在 jdk1.6 中才开始提供的，在此之前，新生代的 Parallel Scavenge收集器一直处于比较尴尬的状态。原因是如果新生代 Parallel Scavenge 收集器，那么老年代除了 Serial Old(PS MarkSweep)收集器外别无选择。由于单线程的老年代 Serial Old 收集器在服务端应用性能上的”拖累“，即使使用了 Parallel Scavenge 收集器也未必能在整体应用上获得吞吐量最大化的效果，又因为老年代收集中无法充分利用服务器多 CPU 的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有 ParNew 加 CMS 的组合”给力“。直到 Parallel Old 收集器出现后，”吞吐量优先“收集器终于有了比较名副其实的应用祝贺，在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。<br>-UseParallelGC: 虚拟机运行在 Server 模式下的默认值，打开此开关后，使用 ParallelScavenge + Serial Old 的收集器组合进行内存回收。-UseParallelOldGC: 打开此开关后，使用 Parallel Scavenge + Parallel Old 的收集器组合进行垃圾回收CMS 收集器<br>CMS(Concurrent Mark Swep)收集器是一个比较重要的回收器，现在应用非常广泛，我们重点来看一下，CMS 一种获取最短回收停顿时间为目标的收集器，这使得它很适合用于和用户交互的业务。从名字(Mark Swep)就可以看出，CMS 收集器是基于标记清除算法实现的。它的收集过程分为四个步骤：<br>初始标记(initial mark)<br>并发标记(concurrent mark)<br>重新标记(remark)</p><p>并发清除(concurrent sweep)<br>注意初始标记和重新标记还是会 stop the world，但是在耗费时间更长的并发标记和并发清除两个阶段都可以和用户进程同时工作。<br>G1 收集器<br>G1 收集器是一款面向服务端应用的垃圾收集器。HotSpot 团队赋予它的使命是在未来替换掉<br>JDK1.5 中发布的 CMS 收集器。与其他 GC 收集器相比，G1 具备如下特点：<br>并行与并发：G1 能更充分的利用 CPU，多核环境下的硬件优势来缩短 stop the world 的停顿时间。<br>分代收集：和其他收集器一样，分代的概念在 G1 中依然存在，不过 G1 不需要其他的垃圾回收器的配合就可以独自管理整个 GC 堆。<br>空间整合：G1 收集器有利于程序长时间运行，分配大对象时不会无法得到连续的空间而提前触发一次 GC。<br>可预测的非停顿：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注<br>点，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过<br>N 毫秒。<br>CMS：采用标记清除算法<br>解决这个问题的办法就是可以让 CMS 在进行一定次数的 Full GC（标记清除）的时候进行一次标记整理算法，CMS 提供了以下参数来控制：<br>-XX:UseCMSCompactAtFullCollection -XX:CMSFullGCBeforeCompaction=5<br>也就是 CMS 在进行 5 次 Full GC（标记清除）之后进行一次标记整理算法，从而可以控制老年带的碎片在一定的数量以内，甚至可以配置 CMS 在每次 Full GC 的时候都进行内存的整理。</p><h3 id="2、类加载过程"><a href="#2、类加载过程" class="headerlink" title="2、类加载过程"></a>2、类加载过程</h3><p>考察点： JVM<br>回答：<br>如下图所示，JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们<br>就分别来看一下这五个过程。</p><p> <img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/%E8%BF%87%E7%A8%8B.png" alt="过程"></p><p>加载<br>加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。<br>验证这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>准备<br>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</p><p>public static int v = 8080;</p><p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 putstatic 指令是程序被编译后，存放于类构造器<client>方法之中，这里我们后面会解释。<br>但是注意如果声明为：</p><p>public static final int v = 8080;</p><p>在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。<br>解析<br>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class文件中的：<br>CONSTANT_Class_info<br>CONSTANT_Field_info</p><p>CONSTANT_Method_info等类型的常量。<br>下面我们解释一下符号引用和直接引用的概念：<br>符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。<br>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。<br>初始化<br>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。<br>初始化阶段是执行类构造器<client>方法的过程。<client>方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证<client>方法执行之前父<br>类的<client>方法已经执行完毕。p.s: 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成<client>()方法。<br>注意以下几种情况不会执行类初始化：<br>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。<br>定义对象数组，不会触发该类的初始化。<br>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。<br>通过类名获取 Class 对象，不会触发类的初始化。<br>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。<br>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。<br>类加载器<br>虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM<br>提供了 3 种类加载器：<br>启动类加载器(Bootstrap ClassLoader)：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs 系统变量指定路径中的类库。<br>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</p><p>JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。</p><p><img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/%E5%8A%A0%E8%BD%BD%E5%99%A8.png" alt="加载器"></p><p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</p><h3 id="3、JVM分区"><a href="#3、JVM分区" class="headerlink" title="3、JVM分区"></a>3、JVM分区</h3><p>考察点： JVM<br>回答：</p><p><img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/JVM%E5%88%86%E5%8C%BA.png" alt="JVM分区"></p><p>java 内存通常被划分为 5 个区域：程序计数器（Program Count Register）、本地方法栈<br>（Native Stack）、方法区（Methon Area）、栈（Stack）、堆（Heap）。</p><h3 id="4、eden-区，survial-区"><a href="#4、eden-区，survial-区" class="headerlink" title="4、eden 区，survial 区?"></a>4、eden 区，survial 区?</h3><p>考察点： JVM<br>回答：<br>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成 Eden 空间、 From Survivor 和 To Survivor 三块区域。<br>我们把 Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后：</p><p> 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；<br> 2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系：<br>From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。<br>而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor<br>这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p><h3 id="5、JAVA-虚拟机的作用"><a href="#5、JAVA-虚拟机的作用" class="headerlink" title="5、JAVA 虚拟机的作用?"></a>5、JAVA 虚拟机的作用?</h3><p>考察点：a java  虚拟机<br>参考回答：<br>解释运行字节码程序 消除平台相关性。</p><p>jvm 将 java 字节码解释为具体平台的具体指令。一般的高级语言如要在不同的平台上运行，<br>至少需要编译成不同的目标代码。而引入 JVM 后，Java 语言在不同平台上运行时不需要重新编<br>译。Java 语言使用模式 Java 虚拟机屏蔽了与具体平台相关的信息，使得 Java 语言编译程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java<br>虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。<br>假设一个场景，要求 stop the world 时间非常短，你会怎么设计垃圾回收机制？<br>绝大多数新创建的对象分配在 Eden 区。<br>在 Eden 区发生一次 GC 后，存活的对象移到其中一个 Survivor 区。<br>在 Eden 区发生一次 GC 后，对象是存放到 Survivor 区，这个 Survivor 区已经存在其他存活<br>的对象。<br>一旦一个 Survivor 区已满，存活的对象移动到另外一个 Survivor 区。然后之前那个空间已满 Survivor 区将置为空，没有任何数据。<br>经过重复多次这样的步骤后依旧存活的对象将被移到老年代。</p><h3 id="6、GC-中如何判断对象需要被回收？"><a href="#6、GC-中如何判断对象需要被回收？" class="headerlink" title="6、GC 中如何判断对象需要被回收？"></a>6、GC 中如何判断对象需要被回收？</h3><p>考察点：A JAVA  虚拟机<br>回答：<br>即使在可达性分析算法中不可达的对象,也并非是“非回收不可”的,这时候它们暂时处于“等待”阶段,要真正宣告一个对象回收,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法,或者 finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)如果这个对象被判定为有必要执行 finalize()方法,那么这个对象将会放置在一个叫做F-Queue 的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在 finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致 F-Queue 队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱回收的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在 finalize()中跳出回收——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this 关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。</p><h3 id="7、JAVA-虚拟机中，哪些可作为-ROOT-对象？"><a href="#7、JAVA-虚拟机中，哪些可作为-ROOT-对象？" class="headerlink" title="7、JAVA 虚拟机中，哪些可作为 ROOT 对象？"></a>7、JAVA 虚拟机中，哪些可作为 ROOT 对象？</h3><p>考察点： JAVA  虚拟机<br>参考回答：</p><p>虚拟机栈中的引用对象<br>方法区中类静态属性引用的对象<br>方法区中常量引用对象<br>本地方法栈中 JNI 引用对象</p><h3 id="8、JVM-内存模型是什么？"><a href="#8、JVM-内存模型是什么？" class="headerlink" title="8、JVM 内存模型是什么？"></a>8、JVM 内存模型是什么？</h3><p>考察点：JVM  内存模型<br>参考回答：<br>Java 内存模型(简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从<br>抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存<br>（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。<br>本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其关系模型图如下图所示：<img src="https://gitee.com/williamaaa/blogimage/raw/master/img/6.gif" data-original="https://gitee.com/williamaaa/blogimage/raw/master/img/JMM.png" alt="JMM"></p><h3 id="9、jvm-是如何实现线程？"><a href="#9、jvm-是如何实现线程？" class="headerlink" title="9、jvm 是如何实现线程？"></a>9、jvm 是如何实现线程？</h3><p>考察点： JVM<br>回答：</p><p>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。<br>一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件 IO 等)，又可以<br>独立调度。线程是 CPU 调度的基本单位。<br>主流 OS 都提供线程实现。Java 语言提供对线程操作的同一 API，每个已经执行 start()，<br>且还未结束的 java.lang.Thread 类的实例，代表了一个线程。<br>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手<br>段来实现，也可能是为了执行效率。<br>实现线程的方式<br>A.使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持<br>的线程。<br>内核来完成线程切换<br>内核通过调度器 Scheduler 调度线程，并将线程的任务映射到各个 CPU 上<br>程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)<br>用户态和内核态切换消耗内核资源<br>使用用户线程实现<br>系统内核不能感知线程存在的实现<br>用户线程的建立、同步、销毁和调度完全在用户态中完成<br>所有线程操作需要用户程序自己处理，复杂度高<br>用户线程加轻量级进程混合实现<br>轻量级进程作为用户线程和内核线程之间的桥梁</p><h3 id="10、jvm-最大内存限制多少"><a href="#10、jvm-最大内存限制多少" class="headerlink" title="10、jvm 最大内存限制多少"></a>10、jvm 最大内存限制多少</h3><p>考察点： JVM<br>参考回答：<br>(1)堆内存分配<br>JVM 初始分配的内存由-Xms 指定，默认是物理内存的 1/64；JVM 最大分配的内存由-Xmx 指<br>定，默认是物理内存的 1/4。默认空余堆内存小 于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；<br>空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。因此服务器一般设置-Xms、 -Xmx<br>相等以避免在每次 GC 后调整堆的大小。<br>(2)非堆内存分配<br>JVM 使用-XX:PermSize 设置非堆内存初始值，默认是物理内存的 1/64；由 XX:MaxPermSize<br>设置最大非堆内存的大小，默认是物理内存的 1/4。</p><p>(3)VM 最大内存<br>首先 JVM 内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM 内存的最大值跟<br>操作系统有很大的关系。简单的说就 32 位处理器虽 然可控内存空间有 4GB,但是具体的操作系<br>统会给一个限制，这个限制一般是 2GB-3GB（一般来说 Windows 系统下为 1.5G-2G，Linux 系 统下为 2G-3G），而 64bit 以上的处理器就不会有限制了。<br>(3)下面是当前比较流行的几个不同公司不同版本 JVM 最大堆内存:</p><h3 id="11、什么是-Java-虚拟机？为什么-Java-被称作是“平台无关的编程语言”？"><a href="#11、什么是-Java-虚拟机？为什么-Java-被称作是“平台无关的编程语言”？" class="headerlink" title="11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？"></a>11、什么是 Java 虚拟机？为什么 Java 被称作是“平台无关的编程语言”？</h3><p>考察点： JVM<br>回答：<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚<br>拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或<br>者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p><h3 id="12、描述一下-JVM-加载-class-文件的原理机制"><a href="#12、描述一下-JVM-加载-class-文件的原理机制" class="headerlink" title="12、描述一下 JVM 加载 class 文件的原理机制?"></a>12、描述一下 JVM 加载 class 文件的原理机制?</h3><p>考察点： JVM<br>回答：<br>JVM 中类的装载是由 ClassLoader 和它的子类来实现的,Java ClassLoader 是一个重要的Java 运行时系统组件。它负责在运行时查找和装入类文件的类。<br>Java 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种<br>（1）隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载<br>对应的类到 jvm 中，<br>（2）显式装载， 通过 class.forname()等方法，显式加载需要的类 , 隐式加载与显式加载的<br>区别：两者本质是一样的。<br>Java 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java GC</title>
      <link href="/posts/4946.html"/>
      <url>/posts/4946.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、java-中内存泄露是啥，什么时候出现内存泄露？"><a href="#1、java-中内存泄露是啥，什么时候出现内存泄露？" class="headerlink" title="1、java 中内存泄露是啥，什么时候出现内存泄露？"></a>1、java 中内存泄露是啥，什么时候出现内存泄露？</h3><p>考察点：内存泄漏<br>回答：<br>Java 中的内存泄露，广义并通俗的说，就是：不再会被使用的对象的内存不能被回收，就是内存泄露。如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露。</p><h3 id="2、minor-gc-如果运行的很频繁，可能是什么原因引起的，minor-gc-如果运行的很慢，可能是什么原因引起的"><a href="#2、minor-gc-如果运行的很频繁，可能是什么原因引起的，minor-gc-如果运行的很慢，可能是什么原因引起的" class="headerlink" title="2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的很慢，可能是什么原因引起的?"></a>2、minor gc 如果运行的很频繁，可能是什么原因引起的，minor gc 如果运行的很慢，可能是什么原因引起的?</h3><p>考察点： GC<br>回答：<br>可能是堆内存太小。</p><h3 id="3、阐述-GC-算法"><a href="#3、阐述-GC-算法" class="headerlink" title="3、阐述 GC 算法"></a>3、阐述 GC 算法</h3><p>考察点： JVM<br>回答：<br>①GC（GarbageCollection 垃圾收集），GC 的对象是堆空间和永久区<br>②GC 算法包含：引用计数法，标记清除，标记压缩，复制算法。<br>③引用计数器的实现很简单，对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，则对象 A就不可能再被使用。<br>④标记-清除算法是现代垃圾回收算法的思想基础。标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。与标记-清除算法相比，复制算法是一种相对高效的回收方法不适用于存活对象较多的场合如老年代将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p><h3 id="4、GC-是什么-为什么要有-GC"><a href="#4、GC-是什么-为什么要有-GC" class="headerlink" title="4、GC 是什么? 为什么要有 GC?"></a>4、GC 是什么? 为什么要有 GC?</h3><p>考察点：回收<br>回答：<br>GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的 GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。</p><h3 id="5、垃圾回收的优点和原理。并考虑-2-种回收机制"><a href="#5、垃圾回收的优点和原理。并考虑-2-种回收机制" class="headerlink" title="5、垃圾回收的优点和原理。并考虑 2 种回收机制"></a>5、垃圾回收的优点和原理。并考虑 2 种回收机制</h3><p>考察点：垃圾回收<br>回答：<br>Java 语言中一个显著的特点就是引入了垃圾回收机制，使 c++程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有”作用域”的概念，只有对象的引用才有”作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。</p><h3 id="6、java-中会存在内存泄漏吗，请简单描述。"><a href="#6、java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="6、java 中会存在内存泄漏吗，请简单描述。"></a>6、java 中会存在内存泄漏吗，请简单描述。</h3><p>考察点：内存<br>回答：<br>Java 中的确存在 Java 的内存泄漏, 并且事态可以变得相当严重Java garbage collector 自动释放哪些内存里面程序不在需要的对象, 以此避免大多数的其他程序上下文的内存泄漏. 但是 Java 应用程序依旧会有相当的内存泄漏. 查找原因会十分困难.<br>有两类主要的 Java 内存泄漏:</p><ul><li>不再需要的对象引用</li><li>未释放的系统资源</li></ul><p>2.2 非必要的对象引用<br>Java 代码常常保留对于不再需要的对象引用, 并且这组织了内存的垃圾收集器的工作. Java 对象通常被其他对象包含引用, 为此一个单一对象可以保持整个对象树在内存中, 于是导致了如下问题:</p><ul><li><p>在向数组添加对象以后遗漏了对于他们的处理</p></li><li><p>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并<br>且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</p></li><li><p>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.</p></li><li><p>允许一个长久执行的线程所引用的对象. 设置引用为 NULL 也无济于事, 在线程退出和空闲之<br>前, 对象不会被收集释放2.3 未释放的系统资源Java 方法可以定位 Java 实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java 常常通过JNI(Java Native Interface)调用 C/C++子程序定位这些资源.</p></li></ul><h3 id="7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收）"><a href="#7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收）" class="headerlink" title="7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收）"></a>7、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收）</h3><p>考察点：垃圾回收<br>回答：<br>对于 GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC 确定一些对象为”不可达”时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行 System.gc()，通知 GC 运行，但是 Java 语言规范并不保证 GC 一定会执行。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO NIO AIO</title>
      <link href="/posts/10b2.html"/>
      <url>/posts/10b2.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、怎么打印日志？"><a href="#1、怎么打印日志？" class="headerlink" title="1、怎么打印日志？"></a>1、怎么打印日志？</h3><p>考察点：异常<br>回答：<br>cat /var/log/*.log如果日志在更新，如何实时查看 tail -f /var/log/messages还可以使用 watch -d -n 1 cat /var/log/messages-d 表示高亮不同的地方，-n 表示多少秒刷新一次。</p><h3 id="2、运行时异常与一般异常有何异同？"><a href="#2、运行时异常与一般异常有何异同？" class="headerlink" title="2、运行时异常与一般异常有何异同？"></a>2、运行时异常与一般异常有何异同？</h3><p>考察点：异常<br>回答：<br>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><h3 id="3、error-和-exception-有什么区别"><a href="#3、error-和-exception-有什么区别" class="headerlink" title="3、error 和 exception 有什么区别?"></a>3、error 和 exception 有什么区别?</h3><p>考察点：异常</p><p>回答：<br>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</p><h3 id="4、给我一个你最常见到的-runtime-exception"><a href="#4、给我一个你最常见到的-runtime-exception" class="headerlink" title="4、给我一个你最常见到的 runtime exception"></a>4、给我一个你最常见到的 runtime exception</h3><p>考察点：异常<br>回答：</p><pre class=" language-java"><code class="language-java">ArithmeticException<span class="token punctuation">,</span>ArrayStoreException<span class="token punctuation">,</span>BufferOverflowException<span class="token punctuation">,</span>BufferUnderflowException<span class="token punctuation">,</span>CannotRedoException<span class="token punctuation">,</span>CannotUndoException<span class="token punctuation">,</span>ClassCastException<span class="token punctuation">,</span>CMMException<span class="token punctuation">,</span>ConcurrentModificationException<span class="token punctuation">,</span>DOMException<span class="token punctuation">,</span>EmptyStackException<span class="token punctuation">,</span>IllegalArgumentException<span class="token punctuation">,</span>IllegalMonitorStateException<span class="token punctuation">,</span>IllegalPathStateException<span class="token punctuation">,</span>IllegalStateException<span class="token punctuation">,</span>ImagingOpException<span class="token punctuation">,</span>IndexOutOfBoundsException<span class="token punctuation">,</span>MissingResourceException<span class="token punctuation">,</span>NegativeArraySizeException<span class="token punctuation">,</span>NoSuchElementException<span class="token punctuation">,</span>NullPointerException<span class="token punctuation">,</span>ProfileDataException<span class="token punctuation">,</span>ProviderException<span class="token punctuation">,</span>RasterFormatException<span class="token punctuation">,</span> SecurityException<span class="token punctuation">,</span> SystemException<span class="token punctuation">,</span>UndeclaredThrowableException<span class="token punctuation">,</span> UnmodifiableSetException<span class="token punctuation">,</span>UnsupportedOperationException</code></pre><h3 id="5、Java-中的异常处理机制的简单原理和应用。"><a href="#5、Java-中的异常处理机制的简单原理和应用。" class="headerlink" title="5、Java 中的异常处理机制的简单原理和应用。"></a>5、Java 中的异常处理机制的简单原理和应用。</h3><p>考察点：异常<br>回答：<br>当 JAVA 程序违反了 JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。违反语义规则包括 2 种情况。一种是 JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问 null 的对象时会引发 NullPointerException。另一种情况就<br>是 JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable 的子类。</p><h3 id="6、java-中有几种类型的流？JDK-为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#6、java-中有几种类型的流？JDK-为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>6、java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h3><p>考察点： stream<br>回答：<br>字节流，字符流。字节流继承于 InputStream OutputStream，字符流继承于<br>InputStreamReader OutputStreamWriter。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。</p><h3 id="7、什么是-java-序列化，如何实现-java-序列化？"><a href="#7、什么是-java-序列化，如何实现-java-序列化？" class="headerlink" title="7、什么是 java 序列化，如何实现 java 序列化？"></a>7、什么是 java 序列化，如何实现 java 序列化？</h3><p>考察点：序列化<br>回答：<br>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。序列化的实现：将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如：FileOutputStream)来构造一个 ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream 对象的 writeObject(Object obj)方法就可以将参数为 obj 的对象写出(即保存其状态)，要恢复的话则用输入流。</p><h3 id="8、运行时异常与受检异常有什么区别？"><a href="#8、运行时异常与受检异常有什么区别？" class="headerlink" title="8、运行时异常与受检异常有什么区别？"></a>8、运行时异常与受检异常有什么区别？</h3><p>考察点：异常<br>回答：</p><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java 编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在 Effective Java 中对异常的使用给出了以下指导原则：</p><ul><li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在 catch 中忽略掉捕获到的异常</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> IO NIO AIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 锁 JDK 反射</title>
      <link href="/posts/637f.html"/>
      <url>/posts/637f.html</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="1、讲一下非公平锁和公平锁在-reetrantlock-里的实现"><a href="#1、讲一下非公平锁和公平锁在-reetrantlock-里的实现" class="headerlink" title="1、讲一下非公平锁和公平锁在 reetrantlock 里的实现"></a>1、讲一下非公平锁和公平锁在 reetrantlock 里的实现</h3><p>考察点：锁<br>回答：<br>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要 CAS 设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h3 id="2、讲一下-synchronized，可重入怎么实现。"><a href="#2、讲一下-synchronized，可重入怎么实现。" class="headerlink" title="2、讲一下 synchronized，可重入怎么实现。"></a>2、讲一下 synchronized，可重入怎么实现。</h3><p>考察点：锁<br>回答：<br>每个锁关联一个线程持有者和一个计数器。当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM 会记下持有锁的线程，并将计数器计为 1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 synchronized 方法/块时，计数器会递减，如果计数器为 0 则释放该锁。</p><h3 id="3、锁和同步的区别。"><a href="#3、锁和同步的区别。" class="headerlink" title="3、锁和同步的区别。"></a>3、锁和同步的区别。</h3><p>考察点：锁<br>回答：<br>用法上的不同：<br>synchronized 既可以加在方法上，也可以加载特定代码块上，而 lock 需要显示地指定起始位置和终止位置。<br>synchronized 是托管给 JVM 执行的，lock 的锁定是通过代码实现的，它有比 synchronized更精确的线程语义。<br>性能上的不同：<br>lock 接口的实现类 ReentrantLock，不仅具有和 synchronized 相同的并发性和内存语义，还多了超时的获取锁、定时锁、等候和中断锁等。<br>在竞争不是很激烈的情况下，synchronized 的性能优于 ReentrantLock，竞争激烈的情况下synchronized 的性能会下降的非常快，而 ReentrantLock 则基本不变。<br>锁机制不同：<br>synchronized 获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，并且是自动解锁。而 Lock 则需要开发人员手动释放，并且必须在 finally 中释放，否则会引起死锁。</p><h3 id="4、什么是死锁-deadlock-？"><a href="#4、什么是死锁-deadlock-？" class="headerlink" title="4、什么是死锁(deadlock)？"></a>4、什么是死锁(deadlock)？</h3><p>考察点：线程死锁<br>回答：<br>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。例如，如果线程 1 锁住了 A，然后尝试对 B 进行加锁，同时线程 2 已经锁住了 B，接着尝试对 A 进行加锁，这时死锁就发生了。线程 1 永远得不到 B，线程 2 也永远得不到 A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A 和 B），它们将永远阻塞下去。这种情况就是一个死锁。</p><h3 id="5、如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？"><a href="#5、如何确保-N-个线程可以访问-N-个资源同时又不导致死锁？" class="headerlink" title="5、如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？"></a>5、如何确保 N 个线程可以访问 N 个资源同时又不导致死锁？</h3><p>考察点：死锁<br>回答：<br>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。<br>预防死锁，预先破坏产生死锁的四个条件。互斥不可能破坏，所以有如下三种方法：破坏请求和保持条件，进程必须等所有要请求的资源都空闲时才能申请资源，这种方法会使资源浪费严重(有些资源可能仅在运行初期或结束时才使用，甚至根本不使用). 允许进程获取初期所需资源后，便开始运行，运行过程中再逐步释放自己占有的资源，比如有一个进程的任务是把数据复制到磁盘中再打印，前期只需获得磁盘资源而不需要获得打印机资源，待复制完毕后再释放掉磁盘资源。这种方法比第一种方法好，会使资源利用率上升。<br>2.破坏不可抢占条件，这种方法代价大，实现复杂。<br>3.破坏循坏等待条件，对各进程请求资源的顺序做一个规定，避免相互等待。这种方法对资源的利用率比前两种都高，但是前期要为设备指定序号，新设备加入会有一个问题，其次对用户编程也有限制。</p><h3 id="6、请你简述-synchronized-和-java-util-concurrent-locks-Lock-的异同？"><a href="#6、请你简述-synchronized-和-java-util-concurrent-locks-Lock-的异同？" class="headerlink" title="6、请你简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？"></a>6、请你简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？</h3><p>考察点：锁机制<br>回答：<br>主要相同点：Lock 能完成 synchronized 所实现的所有功能<br>主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且必须在 finally 从句中释放。</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><h3 id="1、Java-中的-LongAdder-和-AtomicLong-的区别"><a href="#1、Java-中的-LongAdder-和-AtomicLong-的区别" class="headerlink" title="1、Java 中的 LongAdder 和 AtomicLong 的区别"></a>1、Java 中的 LongAdder 和 AtomicLong 的区别</h3><p>考点： JDK<br>回答：<br>JDK1.8 引入了 LongAdder 类。CAS 机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap的实现思想，应该可以想到对一种传统AtomicInteger等原子类的改进思路。虽然 CAS 操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将 AtomicInteger的内部核心数据 value 分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字<br>进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据 value 被分离成多个单元cell，每个 cell 独自维护内部的值，当前对象的实际值由所有的 cell 累计合成，这样热点就进行了有效的分离，提高了并行度。</p><h3 id="2、JDK-和-JRE-的区别是什么？"><a href="#2、JDK-和-JRE-的区别是什么？" class="headerlink" title="2、JDK 和 JRE 的区别是什么？"></a>2、JDK 和 JRE 的区别是什么？</h3><p>考察点： JDK<br>回答：<br>Java 运行时环境(JRE)是将要执行 Java 程序的 Java 虚拟机。它同时也包含了执行 applet需要的浏览器插件。Java 开发工具包(JDK)是完整的 Java 软件开发包，包含了 JRE，编译器和其他的工具(比如：JavaDoc，Java 调试器)，可以让开发者开发、编译、执行 Java 应用程序。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="1、反射的实现与作用"><a href="#1、反射的实现与作用" class="headerlink" title="1、反射的实现与作用"></a>1、反射的实现与作用</h3><p>考察点：反射<br>回答；<br>JAVA 语言编译之后会生成一个.class 文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</p><p>作用：反射机制指的是程序在运行时能够获取自身的信息。在 JAVA 中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 锁 </tag>
            
            <tag> JDK </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程2</title>
      <link href="/posts/da67.html"/>
      <url>/posts/da67.html</url>
      
        <content type="html"><![CDATA[<h3 id="17、同步方法和同步代码块的区别是什么？"><a href="#17、同步方法和同步代码块的区别是什么？" class="headerlink" title="17、同步方法和同步代码块的区别是什么？"></a>17、同步方法和同步代码块的区别是什么？</h3><p>考察点：A JAVA  代码块同步<br>回答：<br>区别：<br>同步方法默认用 this 或者当前类 class 对象作为锁；</p><p>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；</p><h3 id="18、在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？"><a href="#18、在监视器-Monitor-内部，是如何做线程同步的？程序应该做哪种级别的同步？" class="headerlink" title="18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？"></a>18、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？</h3><p>考察点： JAVA  线程同步<br>回答：<br>监视器和锁在 Java 虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。</p><h3 id="19、sleep-和-wait-有什么区别？"><a href="#19、sleep-和-wait-有什么区别？" class="headerlink" title="19、sleep() 和 wait() 有什么区别？"></a>19、sleep() 和 wait() 有什么区别？</h3><p>考察点：线程<br>回答：<br>sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用 sleep 不会释放对象锁。wait 是 Object 类的方法，对此对象调用 wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 notify方法（或 notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</p><h3 id="20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>20、同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h3><p>考察点：线程同步<br>回答：<br>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p><h3 id="21、设计-4-个线程，其中两个线程每次对-j-增加-1，另外两个线程对-j-每次减少1。使用内部类实现线程，对-j-增减的时候没有考虑顺序问题。"><a href="#21、设计-4-个线程，其中两个线程每次对-j-增加-1，另外两个线程对-j-每次减少1。使用内部类实现线程，对-j-增减的时候没有考虑顺序问题。" class="headerlink" title="21、设计 4 个线程，其中两个线程每次对 j 增加 1，另外两个线程对 j 每次减少1。使用内部类实现线程，对 j 增减的时候没有考虑顺序问题。"></a>21、设计 4 个线程，其中两个线程每次对 j 增加 1，另外两个线程对 j 每次减少1。使用内部类实现线程，对 j 增减的时候没有考虑顺序问题。</h3><p>考察点：JAVA  线程<br>回答：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTest1</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">int</span> j<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>ThreadTest1 tt<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ThreadTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Inc inc<span class="token operator">=</span>tt<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Dec dec<span class="token operator">=</span>tt<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Dec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Thread t<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>inc<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>dec<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>j<span class="token operator">++</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-inc:"</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">dec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>j<span class="token operator">--</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"-dec:"</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Inc</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dec</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">dec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="22、启动一个线程是用-run-还是-start"><a href="#22、启动一个线程是用-run-还是-start" class="headerlink" title="22、启动一个线程是用 run()还是 start()?"></a>22、启动一个线程是用 run()还是 start()?</h3><p>考察点：JAVA  线程<br>回答：<br>启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</p><h3 id="23、请说出你所知道的线程同步的方法"><a href="#23、请说出你所知道的线程同步的方法" class="headerlink" title="23、请说出你所知道的线程同步的方法"></a>23、请说出你所知道的线程同步的方法</h3><p>考察点：线程同步<br>回答：<br>wait():使一个线程处于等待状态，并且释放所持有的对象的 lock。sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常。notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让<br>它们竞争。</p><h3 id="24、多线程有几种实现方法-都是什么-同步有几种实现方法-都是什么"><a href="#24、多线程有几种实现方法-都是什么-同步有几种实现方法-都是什么" class="headerlink" title="24、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?"></a>24、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?</h3><p>考察点：线程<br>回答：<br>多线程有两种实现方法，分别是继承Thread类与实现Runnable接口同步的实现方面有两种，分别是synchronized,wait 与 notify。</p><h3 id="25、java-中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和-suspend-方法为何不推荐使用？"><a href="#25、java-中有几种方法可以实现一个线程？用什么关键字修饰同步方法-stop-和-suspend-方法为何不推荐使用？" class="headerlink" title="25、java 中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和 suspend()方法为何不推荐使用？"></a>25、java 中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和 suspend()方法为何不推荐使用？</h3><p>考察点：线程<br>回答：<br>有两种实现方法，分别是继承 Thread 类与实现 Runnable 接口用 synchronized 关键字修饰同步方法，反对使用 stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用 suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用 suspend()，而应在自己的 Thread 类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个 notify()重新启动线程。</p><h3 id="26、线程的-sleep-方法和-yield-方法有什么区别？"><a href="#26、线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="26、线程的 sleep()方法和 yield()方法有什么区别？"></a>26、线程的 sleep()方法和 yield()方法有什么区别？</h3><p>考察点：线程<br>回答：<br>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；<br>② 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；<br>③ sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；<br>④ sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</p><h3 id="27、当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？"><a href="#27、当一个线程进入一个对象的-synchronized-方法-A-之后，其它线程是否可进入此对象的-synchronized-方法-B？" class="headerlink" title="27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？"></a>27、当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？</h3><p>考察点：线程<br>回答：</p><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><h3 id="28、请说出与线程同步以及线程调度相关的方法。"><a href="#28、请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="28、请说出与线程同步以及线程调度相关的方法。"></a>28、请说出与线程同步以及线程调度相关的方法。</h3><p>考察点：线程同步<br>参考回答：</p><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException 异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；通过 Lock 接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock 接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了 newCondition()方法来产生用于线程之间通信的 Condition 对象；此外，Java 5 还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用 Semaphore 对象的 acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用 Semaphore 对象的 release()方法）。</li></ul><h3 id="29、举例说明同步和异步"><a href="#29、举例说明同步和异步" class="headerlink" title="29、举例说明同步和异步"></a>29、举例说明同步和异步</h3><p>考察点：线程<br>回答：<br>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</p><h3 id="30、什么是线程池（thread-pool）？"><a href="#30、什么是线程池（thread-pool）？" class="headerlink" title="30、什么是线程池（thread pool）？"></a>30、什么是线程池（thread pool）？</h3><p>考察点：线程池<br>回答：<br>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。Java 5+中的 Executor 接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><ul><li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</li><li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li><li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h3 id="31、说说线程的基本状态以及状态之间的关系？"><a href="#31、说说线程的基本状态以及状态之间的关系？" class="headerlink" title="31、说说线程的基本状态以及状态之间的关系？"></a>31、说说线程的基本状态以及状态之间的关系？</h3><p>考察点：线程<br>回答：<br>其中 Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU），Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep()方法或 join()方法等待休眠或其他线程结束，或是因为发生了 I/O 中断。</p><h3 id="32、如何保证线程安全？"><a href="#32、如何保证线程安全？" class="headerlink" title="32、如何保证线程安全？"></a>32、如何保证线程安全？</h3><p>考察点：线程<br>回答：<br>通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程1</title>
      <link href="/posts/db27.html"/>
      <url>/posts/db27.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、多线程中的-i-线程安全吗？为什么？"><a href="#1、多线程中的-i-线程安全吗？为什么？" class="headerlink" title="1、多线程中的 i++线程安全吗？为什么？"></a>1、多线程中的 i++线程安全吗？为什么？</h3><p>考察点：多线程<br>回答：<br>不安全。i++不是原子性操作。i++分为读取 i 值，对 i 值加一，再赋值给 i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h3 id="2、如何线程安全的实现一个计数器？"><a href="#2、如何线程安全的实现一个计数器？" class="headerlink" title="2、如何线程安全的实现一个计数器？"></a>2、如何线程安全的实现一个计数器？</h3><p>考察点：多线程<br>回答：<br>可以使用加锁，比如 synchronized 或者 lock。也可以使用 Concurrent 包下的原子类。</p><h3 id="3、多线程同步的方法"><a href="#3、多线程同步的方法" class="headerlink" title="3、多线程同步的方法"></a>3、多线程同步的方法</h3><p>考察点：多线程<br>回答：<br>可以使用 synchronized、lock、volatile 和 ThreadLocal 来实现同步。</p><h3 id="4、介绍一下生产者消费者模式？"><a href="#4、介绍一下生产者消费者模式？" class="headerlink" title="4、介绍一下生产者消费者模式？"></a>4、介绍一下生产者消费者模式？</h3><p>考察点：线程<br>回答：</p><p>生产者—–&gt;缓冲区—–&gt;消费者</p><p>生产者消费者问题是线程模型中的经典问题：生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。<br>优点：支持并发、解耦。</p><h3 id="5、线程，进程，然后线程创建有很大开销，怎么优化？"><a href="#5、线程，进程，然后线程创建有很大开销，怎么优化？" class="headerlink" title="5、线程，进程，然后线程创建有很大开销，怎么优化？"></a>5、线程，进程，然后线程创建有很大开销，怎么优化？</h3><p>考察点：多线程<br>回答：<br>可以使用线程池。</p><h3 id="6、线程池运行流程，参数，策略"><a href="#6、线程池运行流程，参数，策略" class="headerlink" title="6、线程池运行流程，参数，策略"></a>6、线程池运行流程，参数，策略</h3><p>考察点：线程池<br>回答：<br>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。</p><h3 id="7、讲一下-AQS-吧。"><a href="#7、讲一下-AQS-吧。" class="headerlink" title="7、讲一下 AQS 吧。"></a>7、讲一下 AQS 吧。</h3><p>考察点：多线程<br>回答：<br>AQS 其实就是一个可以给我们实现锁的框架内部实现的关键是：先进先出的队列、state 状态定义了内部类 ConditionObject拥有两种线程模式独占模式和共享模式。在 LOCK 包中的相关锁(常用的有 ReentrantLock、 ReadWriteLock)都是基于 AQS 来构建，一般我们叫 AQS 为同步器。</p><h3 id="8、创建线程的方法，哪个更好，为什么？"><a href="#8、创建线程的方法，哪个更好，为什么？" class="headerlink" title="8、创建线程的方法，哪个更好，为什么？"></a>8、创建线程的方法，哪个更好，为什么？</h3><p>考察点：线程<br>回答：<br>需要从 Java.lang.Thread 类派生一个新的线程类，重载它的 run()方法；实现 Runnalbe 接口，重载 Runnalbe 接口中的 run()方法。实现 Runnalbe 接口更好，使用实现 Runnable 接口的方式创建的线程可以处理同一资源，从<br>而实现资源的共享.</p><h3 id="9、Java-中有几种方式启动一个线程？"><a href="#9、Java-中有几种方式启动一个线程？" class="headerlink" title="9、Java 中有几种方式启动一个线程？"></a>9、Java 中有几种方式启动一个线程？</h3><p>考察点：线程</p><p>回答：</p><ol><li>继承自 Thread 类</li><li>实现 Runnable 接口</li><li>即实现 Runnable 接口，也继承 Thread 类，并重写 run 方法</li></ol><h3 id="10、Java-中有几种线程池？"><a href="#10、Java-中有几种线程池？" class="headerlink" title="10、Java 中有几种线程池？"></a>10、Java 中有几种线程池？</h3><p>考察点：线程池<br>回答：<br>1、newFixedThreadPool 创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>2、newCachedThreadPool 创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE),这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为 1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。<br>3、newSingleThreadExecutor 创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。<br>4、newScheduleThreadPool 创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于 Timer。(这种线程池原理暂还没完全了解透彻)</p><h3 id="11、线程池有什么好处？"><a href="#11、线程池有什么好处？" class="headerlink" title="11、线程池有什么好处？"></a>11、线程池有什么好处？</h3><p>考察点：线程池<br>回答：<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。<br>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。<br>第三：提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><h3 id="12、cyclicbarrier-和-countdownlatch-的区别"><a href="#12、cyclicbarrier-和-countdownlatch-的区别" class="headerlink" title="12、cyclicbarrier 和 countdownlatch 的区别"></a>12、cyclicbarrier 和 countdownlatch 的区别</h3><p>考察点：线程</p><p>参考回答：<br>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同：CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。</p><h3 id="13、启动线程有哪几种方式，线程池有哪几种？"><a href="#13、启动线程有哪几种方式，线程池有哪几种？" class="headerlink" title="13、启动线程有哪几种方式，线程池有哪几种？"></a>13、启动线程有哪几种方式，线程池有哪几种？</h3><p>考察点：线程池<br>参考回答：<br>①启动线程有如下三种方式：<br>一、继承 Thread 类创建线程类<br>（1）定义 Thread 类的子类，并重写该类的 run 方法，该 run 方法的方法体就代表了线程要完成的任务。因此把 run()方法称为执行体。<br>（2）创建 Thread 子类的实例，即创建了线程对象。<br>（3）调用线程对象的 start()方法来启动该线程。<br>代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FirstThreadTest</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重写 run 方法，run 方法的方法体就是现场执行体</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" : "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">FirstThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">FirstThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码中 Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。<br>二、通过 Runnable 接口创建线程类<br>（1）定义 runnable 接口的实现类，并重写该接口的 run()方法，该 run()方法的方法体同样<br>是该线程的线程执行体。<br>（2）创建 Runnable 实现类的实例，并依此实例作为 Thread 的 target 来创建 Thread 对象，<br>该 Thread 对象才是真正的线程对象。<br>（3）调用线程对象的 start()方法来启动该线程。<br>代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableThreadTest</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span>RunnableThreadTest rtt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RunnableThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>rtt<span class="token punctuation">,</span><span class="token string">"新线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>rtt<span class="token punctuation">,</span><span class="token string">"新线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>三、通过 Callable 和 Future 创建线程<br>（1）创建 Callable 接口的实现类，并实现 call()方法，该 call()方法将作为线程执行体，并且有返回值。<br>（2）创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask对象封装了该 Callable 对象的 call()方法的返回值。<br>（3）使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。<br>（4）调用 FutureTask 对象的 get()方法来获得子线程执行结束后的返回值</p><pre class=" language-java"><code class="language-java">代码：<span class="token keyword">package</span> com<span class="token punctuation">.</span>thread<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Callable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutionException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>FutureTask<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CallableThreadTest</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>CallableThreadTest ctt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CallableThreadTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FutureTask<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ft <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>ctt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>" 的循环变量 i 的值"<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ft<span class="token punctuation">,</span><span class="token string">"有返回值的线程"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">try</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子线程的返回值："</span><span class="token operator">+</span>ft<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>②线程池的种类有：<br>Java 通过 Executors 提供四种线程池，分别为：newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。<br>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><h3 id="14、如何理解-Java-多线程回调方法？"><a href="#14、如何理解-Java-多线程回调方法？" class="headerlink" title="14、如何理解 Java 多线程回调方法？"></a>14、如何理解 Java 多线程回调方法？</h3><p>考察点： JAVA  多线程</p><p>回答：<br>所谓回调，就是客户程序 C 调用服务程序 S 中的某个方法 A，然后 S 又在某个时候反过来调用 C 中的某个方法 B，对于 C 来说，这个 B 便叫做回调方法。</p><h3 id="15、创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#15、创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="15、创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>15、创建线程有几种不同的方式？你喜欢哪一种？为什么？</h3><p>考察点： JAVA  线程<br>回答：<br>有三种方式可以用来创建线程：<br>继承 Thread 类<br>实现 Runnable 接口<br>应用程序可以使用 Executor 框架来创建线程池<br>实现 Runnable 接口这种方式更受欢迎，因为这不需要继承 Thread 类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而 Java 不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</p><h3 id="16、概括的解释下线程的几种可用状态。"><a href="#16、概括的解释下线程的几种可用状态。" class="headerlink" title="16、概括的解释下线程的几种可用状态。"></a>16、概括的解释下线程的几种可用状态。</h3><p>考察点：JAVA  线程状态<br>参考回答：</p><ol><li>新建( new )：新创建了一个线程对象。</li><li>可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。</li><li>运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。</li><li>阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cputimeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cputimeslice 转到运行( running )状态。阻塞的情况分三种：<br>(一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。<br>(二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。<br>(三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。 当 sleep ()状态超时、join()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。</li><li>死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合2</title>
      <link href="/posts/2b92.html"/>
      <url>/posts/2b92.html</url>
      
        <content type="html"><![CDATA[<h3 id="13、为什么集合类没有实现-Cloneable-和-Serializable-接口？"><a href="#13、为什么集合类没有实现-Cloneable-和-Serializable-接口？" class="headerlink" title="13、为什么集合类没有实现 Cloneable 和 Serializable 接口？"></a>13、为什么集合类没有实现 Cloneable 和 Serializable 接口？</h3><p>考察点： JAVA  集合<br>回答：<br>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现 Serializable 序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable 接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化.</p><h3 id="14、什么是迭代器？"><a href="#14、什么是迭代器？" class="headerlink" title="14、什么是迭代器？"></a>14、什么是迭代器？</h3><p>考察点： JAVA  迭代器<br>回答：<br>Iterator 提供了统一遍历操作集合元素的统一接口, Collection 接口实现 Iterable 接口,每个集合都通过实现 Iterable 接口中 iterator()方法返回 Iterator 接口的实例, 然后对集合的元素进行迭代操作.有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException异常. 但是可以通过 Iterator 接口中的 remove()方法进行删除.</p><h3 id="15、Iterator-和-ListIterator-的区别是什么？"><a href="#15、Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="15、Iterator 和 ListIterator 的区别是什么？"></a>15、Iterator 和 ListIterator 的区别是什么？</h3><p>考察点：迭代器<br>回答：<br>Iterator 和 ListIterator 的区别是：<br>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。<br>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。<br>ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p><h3 id="16、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？"><a href="#16、快速失败-fail-fast-和安全失败-fail-safe-的区别是什么？" class="headerlink" title="16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？"></a>16、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？</h3><p>考察点：集合<br>回答：<br>Iterator 的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util 包下面的所有的集合类都是快速失败的，而 java.util.concurrent 包下面的所有的类都是安全失败的。快速失败的迭代器会抛出 ConcurrentModificationException 异常，而安全失败的迭代器永远不会抛出这样的异常。</p><h3 id="17、HashMap-和-Hashtable-有什么区别？"><a href="#17、HashMap-和-Hashtable-有什么区别？" class="headerlink" title="17、HashMap 和 Hashtable 有什么区别？"></a>17、HashMap 和 Hashtable 有什么区别？</h3><p>考察点：集合<br>回答：<br>HashMap 和 Hashtable 都实现了 Map 接口，因此很多特性非常相似。但是，他们有以下不同点：<br>HashMap 允许键和值是 null，而 Hashtable 不允许键或者值是 null。<br>Hashtable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 Hashtable 适合于多线程环境。<br>HashMap 提供了可供应用迭代的键的集合，因此，HashMap 是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为 Hashtable 是一个遗留的类。</p><h3 id="18、ArrayList-和-LinkedList-有什么区别？"><a href="#18、ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="18、ArrayList 和 LinkedList 有什么区别？"></a>18、ArrayList 和 LinkedList 有什么区别？</h3><p>考察点： ArrayList<br>回答：</p><p>ArrayList 和 LinkedList 都实现了 List 接口，他们有以下的不同点：<br>ArrayList 是基于索引的数据接口，它的底层是数组。它可以以 O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList 是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。相对于 ArrayList，LinkedList 的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList 比 ArrayList 更占内存，因为 LinkedList 为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</p><h3 id="19、ArrayList-Vector-LinkedList-的存储性能和特性是什么？"><a href="#19、ArrayList-Vector-LinkedList-的存储性能和特性是什么？" class="headerlink" title="19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？"></a>19、ArrayList,Vector,LinkedList 的存储性能和特性是什么？</h3><p>考察点： ArrayList<br>回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector<br>由于使用了 synchronized 方法（线程安全），通常性能上较 ArrayList 差，而 LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</p><h3 id="20、Collection-和-Collections-的区别。"><a href="#20、Collection-和-Collections-的区别。" class="headerlink" title="20、Collection 和 Collections 的区别。"></a>20、Collection 和 Collections 的区别。</h3><p>考察点：集合<br>回答：<br>Collection 是集合类的上级接口，继承与他的接口主要有 Set 和 List.<br>Collections 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h3 id="21、你所知道的集合类都有哪些？主要方法？"><a href="#21、你所知道的集合类都有哪些？主要方法？" class="headerlink" title="21、你所知道的集合类都有哪些？主要方法？"></a>21、你所知道的集合类都有哪些？主要方法？</h3><p>考察点：集合<br>回答：<br>最常用的集合类是 List 和 Map。 List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。 List 适用于按数值索引访问元素的情形。Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h3 id="22、List、Set、Map-是否继承自-Collection-接口？"><a href="#22、List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="22、List、Set、Map 是否继承自 Collection 接口？"></a>22、List、Set、Map 是否继承自 Collection 接口？</h3><p>考察点：collection  接口<br>回答：<br>List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p><h3 id="23、阐述-ArrayList、Vector、LinkedList-的存储性能和特性"><a href="#23、阐述-ArrayList、Vector、LinkedList-的存储性能和特性" class="headerlink" title="23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性"></a>23、阐述 ArrayList、Vector、LinkedList 的存储性能和特性</h3><p>考察点： ArrayList<br>回答：<br>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由于添加了 synchronized 修饰，因此 Vector是线程安全的容器，但性能上较 ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号<br>索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和LinkedListed 都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><h3 id="24、List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#24、List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="24、List、Map、Set 三个接口存取元素时，各有什么特点？"></a>24、List、Map、Set 三个接口存取元素时，各有什么特点？</h3><p>考察点： List<br>回答：<br>List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象的 equals()方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合1</title>
      <link href="/posts/5257.html"/>
      <url>/posts/5257.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、Map-和-ConcurrentHashMap-的区别？"><a href="#1、Map-和-ConcurrentHashMap-的区别？" class="headerlink" title="1、Map 和 ConcurrentHashMap 的区别？"></a>1、Map 和 ConcurrentHashMap 的区别？</h3><p>考点：集合<br>回答：<br>hashmap 是线程不安全的，put 时在多线程情况下，会形成环从而导致死循环。<br>CoucurrentHashMap 是线程安全的，采用分段锁机制，减少锁的粒度。</p><h3 id="2、hashMap-内部具体如何实现的？"><a href="#2、hashMap-内部具体如何实现的？" class="headerlink" title="2、hashMap 内部具体如何实现的？"></a>2、hashMap 内部具体如何实现的？</h3><p>考点：集合<br>回答：<br>Hashmap 基于数组实现的，通过对 key 的 hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素 next 指向要插入的元素，这样来解决 hash 冲突的，形成了拉链式的结构。put 时在多线程情况下，会形成环从而导致死循环。数组长度一般是 2n，从 0 开始编号，所以 hashcode &amp; （2n-1），（2n-1）每一位都是 1，这样会让散列均匀。需要注意的是，HashMap 在 JDK1.8 的版本中引入了红黑树结构做优化，当链表元素个数大于等于 8 时，链表转换成树结构；若桶中链表元素个数小于等于 6 时，树结构还原成链表。因为红黑树的平均查找长度是 log(n)，长度为 8 的时候，平均查找长度为 3，如果继续使用链表，平均查找长度为 8/2=4，这才有转换为树的必要。链表长度如果是小于等于 6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择 6 和 8，中间有个差值 7 可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过 8 则链表转换成树结构，链表个数小于 8 则树结构转换成链表，如果一个 HashMap 不停的插入、删除元素，链表个数在 8 左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h3 id="3、如果-hashMap-的-key-是一个自定义的类，怎么办？"><a href="#3、如果-hashMap-的-key-是一个自定义的类，怎么办？" class="headerlink" title="3、如果 hashMap 的 key 是一个自定义的类，怎么办？"></a>3、如果 hashMap 的 key 是一个自定义的类，怎么办？</h3><p>考点：集合<br>回答：<br>使用 HashMap，如果 key 是自定义的类，就必须重写 hashcode()和 equals()。</p><h3 id="4、ArrayList-和-LinkedList-的区别，如果一直在-list-的尾部添加元素，用哪个效率高？"><a href="#4、ArrayList-和-LinkedList-的区别，如果一直在-list-的尾部添加元素，用哪个效率高？" class="headerlink" title="4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪个效率高？"></a>4、ArrayList 和 LinkedList 的区别，如果一直在 list 的尾部添加元素，用哪个效率高？</h3><p>考点：集合<br>回答：</p><p>ArrayList 采用数组数组实现的，查找效率比 LinkedList 高。LinkedList 采用双向链表实现的，插入和删除的效率比 ArrayList 要高。一直在 list 的尾部添加元素，LinkedList 效率要高。</p><h3 id="5、HashMap-底层，负载因子，为啥是-2-n？"><a href="#5、HashMap-底层，负载因子，为啥是-2-n？" class="headerlink" title="5、HashMap 底层，负载因子，为啥是 2^n？"></a>5、HashMap 底层，负载因子，为啥是 2^n？</h3><p>考点：集合<br>回答：<br>负载因子默认是 0.75， 2^n 是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么 hashmap 会由 O（1）复杂退化为 O（n）的。</p><h3 id="6、ConcurrentHashMap-锁加在了哪些地方？"><a href="#6、ConcurrentHashMap-锁加在了哪些地方？" class="headerlink" title="6、ConcurrentHashMap 锁加在了哪些地方？"></a>6、ConcurrentHashMap 锁加在了哪些地方？</h3><p>考点：集合<br>回答：<br>加在每个 Segment 上面。</p><h3 id="7、TreeMap-底层，红黑树原理？"><a href="#7、TreeMap-底层，红黑树原理？" class="headerlink" title="7、TreeMap 底层，红黑树原理？"></a>7、TreeMap 底层，红黑树原理？</h3><p>考点：集合<br>回答：<br>TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。</p><p>红黑树的插入、删除、遍历时间复杂度都为 O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质：<br>性质 1：每个节点要么是红色，要么是黑色。<br>性质 2：根节点永远是黑色的。<br>性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。<br>性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）<br>性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</p><h3 id="8、concurrenthashmap-有啥优势，1-7，1-8-区别？"><a href="#8、concurrenthashmap-有啥优势，1-7，1-8-区别？" class="headerlink" title="8、concurrenthashmap 有啥优势，1.7，1.8 区别？"></a>8、concurrenthashmap 有啥优势，1.7，1.8 区别？</h3><p>考点：集合<br>回答：<br>Concurrenthashmap 线程安全的，1.7 是在 jdk1.7 中采用 Segment + HashEntry 的方式进行实现的，lock 加在 Segment 上面。1.7size 计算是先采用不加锁的方式，连续计算元素的个数，最多计算 3 次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个 Segment 进行加锁，再计算一次元素的个数；1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用 Node + CAS + Synchronized 来保证并发安全进行实现，1.8 中使用一个 volatile 类型的变量 baseCount 记录元素的个数，当插入新数据或则删除数据时，会通过 addCount()方法更新 baseCount，通过累加 baseCount 和CounterCell 数组中的数量，即可得到元素的总个数；</p><h3 id="9、ArrayList-是否会越界？"><a href="#9、ArrayList-是否会越界？" class="headerlink" title="9、ArrayList 是否会越界？"></a>9、ArrayList 是否会越界？</h3><p>考点：集合<br>回答：<br>ArrayList 是实现了基于动态数组的数据结构，而 LinkedList 是基于链表的数据结构 2. 对于随机访问 get 和 set，ArrayList 要优于 LinkedList，因为 LinkedList 要移动指针；ArrayList并发 add()可能出现数组下标越界异常</p><h3 id="10、什么是-TreeMap"><a href="#10、什么是-TreeMap" class="headerlink" title="10、什么是 TreeMap?"></a>10、什么是 TreeMap?</h3><p>考察点：e key-value  集合<br>回答：<br>TreeMap 是一个有序的 key-value 集合，基于红黑树（Red-Black tree）的 NavigableMap实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。<br>TreeMap 的特性：<br>根节点是黑色<br>每个节点都只能是红色或者黑色<br>每个叶节点（NIL 节点，空节点）是黑色的。<br>如果一个节点是红色的，则它两个子节点都是黑色的，也就是说在一条路径上不能出现两个红色的节点。<br>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><h3 id="11、ConcurrentHashMap-的原理是什么？"><a href="#11、ConcurrentHashMap-的原理是什么？" class="headerlink" title="11、ConcurrentHashMap 的原理是什么？"></a>11、ConcurrentHashMap 的原理是什么？</h3><p>考察点：JAVA  内存模型<br>回答：<br>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。每个桶是由若干个 HashEntry 对象链接起来的链表。一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组。HashEntry 用来封装散列映射表中的键值对。在HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HashEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">final</span> K key<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明</span>key 为 <span class="token keyword">final</span> 型<span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明 hash</span>值为 <span class="token keyword">final</span> 型<span class="token keyword">volatile</span> V value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明 value 为</span><span class="token keyword">volatile</span> 型<span class="token keyword">final</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明 next 为 final 型</span><span class="token function">HashEntry</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">,</span> HashEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 下图是在一个空桶中依次插入 A，B，C 三个 HashEntry<br>对象后的结构图：<br>图 1. 插入三个节点后桶的结构示意图：</p><p>HahBucket—–&gt;C—–&gt;B—–&gt;A</p><p>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。<br>Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。每个Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p><h3 id="12、Java-集合类框架的基本接口有哪些？"><a href="#12、Java-集合类框架的基本接口有哪些？" class="headerlink" title="12、Java 集合类框架的基本接口有哪些？"></a>12、Java 集合类框架的基本接口有哪些？</h3><p>考察点：A JAVA  集合<br>回答：<br>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。Java 集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java 集合类里面最基本的接口有：<br>Collection：代表一组对象，每一个对象都是它的子元素。<br>Set：不包含重复元素的 Collection。<br>List：有顺序的 collection，并且可以包含重复元素。<br>Map：可以把键(key)映射到值(value)的对象，键不能重复。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象2</title>
      <link href="/posts/61f0.html"/>
      <url>/posts/61f0.html</url>
      
        <content type="html"><![CDATA[<h3 id="21、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型"><a href="#21、Overload-和-Override-的区别。Overloaded-的方法是否可以改变返回值的类型" class="headerlink" title="21、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?"></a>21、Overload 和 Override 的区别。Overloaded 的方法是否可以改变返回值的类型?</h3><p>考察点：JAVA  多态<br>回答：<br>方法的重写 Overriding 和重载 Overloading 是 Java 多态性的不同表现。重写 Overriding是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被”屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的方法是可以改变返回值的类型。</p><h3 id="22、abstract-class-和-interface-有什么区别"><a href="#22、abstract-class-和-interface-有什么区别" class="headerlink" title="22、abstract class 和 interface 有什么区别?"></a>22、abstract class 和 interface 有什么区别?</h3><p>考察点：抽象类<br>回答：<br>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建 abstract 类的实例。然而可以创建一个变量，其<br>类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义 static final 成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><h3 id="23、Static-Nested-Class-和-Inner-Class-的不同"><a href="#23、Static-Nested-Class-和-Inner-Class-的不同" class="headerlink" title="23、Static Nested Class 和 Inner Class 的不同"></a>23、Static Nested Class 和 Inner Class 的不同</h3><p>考察点：声明<br>回答：<br>Static Nested Class 是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能 Access Outer Class 的动态成员(instance member).而Nested Class 的动态成员(instance method) 却可以 Access Outer Class 的所有成员, 这个概念很重要, 许多人对这个概念模糊.有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而 动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以 Access 跟 object 相关的动态成员(instance member),反过来就可以, 一个 CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member).</p><h3 id="24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递"><a href="#24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递" class="headerlink" title="24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?"></a>24、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?</h3><p>考察点：对象<br>回答：<br>是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><h3 id="25、Java-的接口和-C-的虚类的相同和不同处。"><a href="#25、Java-的接口和-C-的虚类的相同和不同处。" class="headerlink" title="25、Java 的接口和 C++的虚类的相同和不同处。"></a>25、Java 的接口和 C++的虚类的相同和不同处。</h3><p>考察点：接口<br>回答：<br>由于 Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是 public static,所有方法默认情况下是 public.一个类可以实现多个接口。</p><h3 id="26、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在-try-块中可以抛出异常吗？"><a href="#26、JAVA-语言如何进行异常处理，关键字：throws-throw-try-catch-finally分别代表什么意义？在-try-块中可以抛出异常吗？" class="headerlink" title="26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try 块中可以抛出异常吗？"></a>26、JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在 try 块中可以抛出异常吗？</h3><p>考察点：异常<br>回答：<br>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在 Java 中，每个异常都是一个对象，它是 Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过 5 个关键词来实现的：try、catch、throw、throws和 finally。一般情况下是用 try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。<br>用 try 来指定一块预防所有”异常”的程序。紧跟在 try 程序后面，应包含一个 catch 子句来指定你想要捕捉的”异常”的类型。throw 语句用来明确地抛出一个”异常”。throws 用来标明一个成员函数可能抛出的各种”异常”。Finally 为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个 try 语句，在这个成员函数内部写另一个 try语句保护其他代码。每当遇到一个 try 语句，”异常“的框架就放到堆栈上面，直到所有的 try语句都完成。如果下一级的 try 语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的 try 语句。</p><h3 id="27、内部类可以引用他包含类的成员吗？有没有什么限制？"><a href="#27、内部类可以引用他包含类的成员吗？有没有什么限制？" class="headerlink" title="27、内部类可以引用他包含类的成员吗？有没有什么限制？"></a>27、内部类可以引用他包含类的成员吗？有没有什么限制？</h3><p>考察点：类<br>回答：<br>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是 static 的，那么它可以访问创建它的外部类对象的所有属性内部类如果是 sattic 的，即为 nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现 static，protected，private 等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。</p><h3 id="28、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code-说法是否正确？"><a href="#28、两个对象值相同-x-equals-y-true-，但却可有不同的-hash-code-说法是否正确？" class="headerlink" title="28、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code 说法是否正确？"></a>28、两个对象值相同(x.equals(y) == true)，但却可有不同的 hash code 说法是否正确？</h3><p>考察点：对象<br>回答：<br>不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。Java 对于 eqauls 方法和 hashCode 方法是这样规定的：(1)如果两个对象相同（equals方法返回 true），那么它们的 hashCode 值一定要相同；(2)如果两个对象的 hashCode 相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><h3 id="29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>29、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h3><p>考察点：java  重载<br>回答：<br>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</p><h3 id="30、如何通过反射获取和设置对象私有字段的值？"><a href="#30、如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="30、如何通过反射获取和设置对象私有字段的值？"></a>30、如何通过反射获取和设置对象私有字段的值？</h3><p>考察点：类<br>回答：<br>可以通过类对象的 getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过 get/set 方法来获取/设置字段的值了。下面的代码实现了一个反射的工具类，其中的两个静态方法分别用于获取和设置私有字段的值，字段可以是基本类型也可以是对象类型且支持多级对象操作，例如ReflectionUtil.get(dog, “owner.car.engine.id”);可以获得 dog 对象的主人的汽车的引擎的<br>ID 号。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">MethodInvokeTest</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>String str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>Method m <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toUpperCase"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// HELLO</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="31、谈一下面向对象的”六原则一法则”。"><a href="#31、谈一下面向对象的”六原则一法则”。" class="headerlink" title="31、谈一下面向对象的”六原则一法则”。"></a>31、谈一下面向对象的”六原则一法则”。</h3><p>考察点： Java  对象<br>回答：</p><ul><li>单一职责原则：一个类只做它该做的事情。（单一职责原则想表达的就是”高内聚”，写代码最终极的原则只有六个字”高内聚、低耦合”，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化，好的自行车是组装车，从减震叉、刹车到变速器，所有的部件都是可以拆卸和重新组装的，好的乒乓球拍也不是成品拍，一定是底板和胶皮可以拆分和自行组装的，一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）- 开闭原则：软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：①抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；②封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性，可以参考《设计模式精解》一书中对桥梁模式的讲解的章节。）- 依赖倒转原则：面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）里氏替换原则：任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov 女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）</li><li>接口隔离原则：接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java 中的接口代表能力、代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）- 合成聚合复用原则：优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之<br>间简单的说有三种关系，Is-A 关系、Has-A 关系、Use-A 关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是 Has-A关系，合成聚合复用原则想表达的是优先考虑 Has-A 关系而不是 Is-A 关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在 Java 的 API 中也有不少滥用继承的例子，例如 Properties 类继承了 Hashtable 类，Stack 类继承了 Vector 类，这些继承明显就是错误的，更好的做法是在 Properties 类中放置一个 Hashtable 类型的成员并且将其键和值都设置为字符串来存储数据，而 Stack 类的设计也应该是在 Stack 类中放一个 Vector 对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或 Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。</li></ul><h3 id="32、请问-Query-接口的-list-方法和-iterate-方法有什么区别？"><a href="#32、请问-Query-接口的-list-方法和-iterate-方法有什么区别？" class="headerlink" title="32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？"></a>32、请问 Query 接口的 list 方法和 iterate 方法有什么区别？</h3><p>考察点：接口<br>回答：<br>①list()方法无法利用一级缓存和二级缓存（对缓存只写不读），它只能在开启查询缓存的前提下使用查询缓存；iterate()方法可以充分利用缓存，如果目标数据只读或者读取频繁，使用 iterate()方法可以减少性能开销。<br>② list()方法不会引起 N+1 查询问题，而 iterate()方法可能引起 N+1 查询问题</p><h3 id="33、Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？"><a href="#33、Java-中的方法覆盖-Overriding-和方法重载-Overloading-是什么意思？" class="headerlink" title="33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？"></a>33、Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？</h3><p>考察点：方法<br>回答：<br>Java 中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><h3 id="34、Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#34、Java-中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>34、Java 中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h3><p>考察点： JAVA  构造函数<br>回答：<br>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java 编译器会为这个类创建一个默认的构造函数。Java 中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。<br>Java 不支持像 C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java 不会创建默认的复制构造函数。</p><h3 id="35、hashCode-和-equals-方法有什么联系？"><a href="#35、hashCode-和-equals-方法有什么联系？" class="headerlink" title="35、hashCode()和 equals()方法有什么联系？"></a>35、hashCode()和 equals()方法有什么联系？</h3><p>考点：基础<br>回答：<br>Java 对象的 eqauls 方法和 hashCode 方法是这样规定的：<br>➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>➁如果两个对象的 hashCode 相同，它们并不一定相同。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象1</title>
      <link href="/posts/70b0.html"/>
      <url>/posts/70b0.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、wait-方法底层原理"><a href="#1、wait-方法底层原理" class="headerlink" title="1、wait 方法底层原理"></a>1、wait 方法底层原理</h3><p>考察点：基础<br>回答：<br>ObjectSynchronizer::wait 方法通过 object 的对象中找到 ObjectMonitor 对象调用方法void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS)通过ObjectMonitor::AddWaiter调用把新建立的ObjectWaiter对象放入到 _WaitSet 的队列的末尾中然后在 ObjectMonitor::exit 释放锁，接着 thread_ParkEvent-&gt;park 也就是 wait。</p><h3 id="2、Java-有哪些特性，举个多态的例子。"><a href="#2、Java-有哪些特性，举个多态的例子。" class="headerlink" title="2、Java 有哪些特性，举个多态的例子。"></a>2、Java 有哪些特性，举个多态的例子。</h3><p>考察点：语言特性<br>回答：<br>封装、继承、多态。多态：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）</p><h3 id="3、String-为啥不可变？"><a href="#3、String-为啥不可变？" class="headerlink" title="3、String 为啥不可变？"></a>3、String 为啥不可变？</h3><p>考察点：面向对象<br>回答：<br>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。<br>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是HashMap 中的键往往都使用字符串的原因。</p><h3 id="4、类和对象的区别"><a href="#4、类和对象的区别" class="headerlink" title="4、类和对象的区别"></a>4、类和对象的区别</h3><p>考察点：面向对象<br>回答：<br>1.类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。比如：“人”是一个类，而“教师”则是“人”的一个实例。<br>2.对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。</p><h3 id="5、请列举你所知道的-Object-类的方法。"><a href="#5、请列举你所知道的-Object-类的方法。" class="headerlink" title="5、请列举你所知道的 Object 类的方法。"></a>5、请列举你所知道的 Object 类的方法。</h3><p>考察点：面向对象</p><p>回答：<br>Object()默认构造方法。clone() 创建并返回此对象的一个副本。equals(Object obj) 指示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。getClass()返回一个对象的运行时类。hashCode()返回该对象的哈希码值。 notify()唤醒在此对象监视器上等待的单个线程。 notifyAll()唤醒在此对象监视器上等待的所有线程。toString()返回该对象的字符串表示。wait()导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</p><h3 id="6、重载和重写的区别？相同参数不同返回值能重载吗？"><a href="#6、重载和重写的区别？相同参数不同返回值能重载吗？" class="headerlink" title="6、重载和重写的区别？相同参数不同返回值能重载吗？"></a>6、重载和重写的区别？相同参数不同返回值能重载吗？</h3><p>考察点：重载<br>回答：<br>重载(Overloading)<br>（1） 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。<br>重载 Overloading 是一个类中多态性的一种表现。<br>（2） Java 的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。<br>调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。<br>（3） 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。<br>重写（Overriding）<br>（1） 父类与子类之间的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。在 Java 中，子类可继承父类中的方法，而不需要重新编写相同的方法。<br>但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的<br>重写。<br>方法重写又称方法覆盖。<br>（2）若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。<br>如需父类中原有的方法，可使用 super 关键字，该关键字引用了当前类的父类。</p><p>（3）子类函数的访问修饰权限不能少于父类的。</p><h3 id="7、”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？"><a href="#7、”static”关键字是什么意思？Java-中是否可以覆盖-override-一个-private或者是-static-的方法？" class="headerlink" title="7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？"></a>7、”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private或者是 static 的方法？</h3><p>考察点：c static  变量<br>回答：<br>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。<br>Java 中 static 方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。static 方法跟类的任何实例都不相关，所以概念上不适用。</p><h3 id="8、String-能继承吗？"><a href="#8、String-能继承吗？" class="headerlink" title="8、String 能继承吗？"></a>8、String 能继承吗？</h3><p>考察点： String<br>回答：<br>不能，char 数组用 final 修饰的。</p><h3 id="9、StringBuffer-和-StringBuilder-有什么区别，底层实现上呢？"><a href="#9、StringBuffer-和-StringBuilder-有什么区别，底层实现上呢？" class="headerlink" title="9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？"></a>9、StringBuffer 和 StringBuilder 有什么区别，底层实现上呢？</h3><p>考察点：类<br>回答：<br>StringBuffer 线程安全，StringBuilder 线程不安全，底层实现上的话，StringBuffer 其实就是比 StringBuilder 多了 Synchronized 修饰符。</p><h3 id="10、类加载机制，双亲委派模型，好处是什么？"><a href="#10、类加载机制，双亲委派模型，好处是什么？" class="headerlink" title="10、类加载机制，双亲委派模型，好处是什么？"></a>10、类加载机制，双亲委派模型，好处是什么？</h3><p>考察点：类<br>回答：<br>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。使用双亲委派模型的好处在于 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存在在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的 Bootstrap ClassLoader 进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个 java.lang.Object 的同名类并放在 ClassPath 中，那系统中将会出现多个不同的 Object 类，程序将混乱。因此，如果开发者尝试编写一个与 rt.jar 类库中重名的Java 类，可以正常编译，但是永远无法被加载运行。</p><h3 id="11、静态变量存在哪"><a href="#11、静态变量存在哪" class="headerlink" title="11、静态变量存在哪?"></a>11、静态变量存在哪?</h3><p>考察点：类<br>回答：<br>方法区</p><h3 id="12、讲讲什么是泛型？"><a href="#12、讲讲什么是泛型？" class="headerlink" title="12、讲讲什么是泛型？"></a>12、讲讲什么是泛型？</h3><p>考察点：JAVA  泛型<br>回答：<br>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/*List list = new ArrayList();list.add("qqyumidi");list.add("corn");list.add(100);*/</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"qqyumidi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"corn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//list.add(100); // 1 提示编译错误</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>String name <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"name:"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>采用泛型写法后，在//1 处想加入一个 Integer 类型的对象时会出现编译错误，通过List<String>，直接限定了 list 集合中只能含有 String 类型的元素，从而在//2 处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是 String 类型了。</p><h3 id="13、解释-extends-和-super-泛型限定符-上界不存下界不取"><a href="#13、解释-extends-和-super-泛型限定符-上界不存下界不取" class="headerlink" title="13、解释 extends 和 super 泛型限定符-上界不存下界不取"></a>13、解释 extends 和 super 泛型限定符-上界不存下界不取</h3><p>考察点：JAVA  泛型<br>回答：<br>（1）泛型中上界和下界的定义<br>上界 &lt;? extend Fruit&gt;<br>下界 &lt;? super Apple&gt;<br>（2）上界和下界的特点<br>上界的 list 只能 get，不能 add（确切地说不能 add 出除 null 之外的对象，包括 Object）<br>下界的 list 只能 add，不能 get<br>（3）示例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Jonathan</span> <span class="token keyword">extends</span> <span class="token class-name">Apple</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Orange</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CovariantArrays</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//上界</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token operator">></span> flistTop <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistTop<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//add Fruit 对象会报错</span><span class="token comment" spellcheck="true">//flist.add(new Fruit());</span>Fruit fruit1 <span class="token operator">=</span> flistTop<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下界</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Apple<span class="token operator">></span> flistBottem <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistBottem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>flistBottem<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Jonathan</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//get Apple 对象会报错</span><span class="token comment" spellcheck="true">//Apple apple = flistBottem.get(0);</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）上界 &lt;? extend Fruit&gt; ，表示所有继承 Fruit 的子类，但是具体是哪个子类，无法确定，所以调用 add 的时候，要 add 什么类型，谁也不知道。但是 get 的时候，不管是什么子类，不管追溯多少辈，肯定有个父类是 Fruit，所以，我都可以用最大的父类 Fruit 接着，也就是把所有的子类向上转型为 Fruit。下界 &lt;? super Apple&gt;，表示Apple的所有父类，包括Fruit，一直可以追溯到老祖宗Object 。那么当我 add 的时候，我不能 add Apple 的父类，因为不能确定 List 里面存放的到底是哪个父类。但是我可以 add Apple 及其子类。因为不管我的子类是什么类型，它都可以向上转型为 Apple及其所有的父类甚至转型为 Object 。但是当我 get 的时候，Apple 的父类这么多，我用什么接着呢，除了 Object，其他的都接不住。</p><p>所以，归根结底可以用一句话表示，那就是编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把 Apple 对象赋值给 Fruit 的引用，但是如果把 Fruit 对象赋值给 Apple 的引用就必须得用 cast。</p><h3 id="14、是否可以在-static-环境中访问非-static-变量？"><a href="#14、是否可以在-static-环境中访问非-static-变量？" class="headerlink" title="14、是否可以在 static 环境中访问非 static 变量？"></a>14、是否可以在 static 环境中访问非 static 变量？</h3><p>考察点： static  变量<br>回答：<br>static 变量在 Java 中是属于类的，它在所有的实例中的值是一样的。当类被 Java 虚拟机载入的时候，会对 static 变量进行初始化。如果你的代码尝试不用实例来访问非 static 的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p><h3 id="15、谈谈如何通过反射创建对象？"><a href="#15、谈谈如何通过反射创建对象？" class="headerlink" title="15、谈谈如何通过反射创建对象？"></a>15、谈谈如何通过反射创建对象？</h3><p>考察点：类<br>回答：</p><ul><li>方法 1：通过类对象调用 newInstance()方法，例如：String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象，例如：<br>String.class.getConstructor(String.class).newInstance(“Hello”);</li></ul><h3 id="16、Java-支持多继承么？"><a href="#16、Java-支持多继承么？" class="headerlink" title="16、Java 支持多继承么？"></a>16、Java 支持多继承么？</h3><p>考察点： JAVA  多继承<br>回答：<br>Java 中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是 java 中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h3 id="17、接口和抽象类的区别是什么？"><a href="#17、接口和抽象类的区别是什么？" class="headerlink" title="17、接口和抽象类的区别是什么？"></a>17、接口和抽象类的区别是什么？</h3><p>考察点：抽象类<br>回答：<br>Java 提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。类可以实现很多个接口，但是只能继承一个抽象类类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。</p><p>抽象类可以在不提供接口方法实现的情况下实现接口。<br>Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。<br>Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private，protected 或者是 public。<br>接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。<br>也可以参考 JDK8 中抽象类和接口的区别</p><h3 id="18、Comparable-和-Comparator-接口是干什么的？列出它们的区别。"><a href="#18、Comparable-和-Comparator-接口是干什么的？列出它们的区别。" class="headerlink" title="18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。"></a>18、Comparable 和 Comparator 接口是干什么的？列出它们的区别。</h3><p>考察点：comparable  接口<br>回答：<br>Java 提供了只包含一个 compareTo()方法的 Comparable 接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。Java 提供了包含 compare()和 equals()两个方法的 Comparator 接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和 comparator 相等。只有当输入参数也是一个 comparator 并且输入参数和当前 comparator 的排序结果是相同的时候，这个方法才返回true。</p><h3 id="19、面向对象的特征有哪些方面"><a href="#19、面向对象的特征有哪些方面" class="headerlink" title="19、面向对象的特征有哪些方面"></a>19、面向对象的特征有哪些方面</h3><p>考察点： JAVA  特征<br>回答：<br>(1)抽象：<br>抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。<br>(2)继承：<br>继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原<br>始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。<br>(3)封装：<br>封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。<br>(4) 多态性：<br>多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</p><h3 id="20、final-finally-finalize-的区别。"><a href="#20、final-finally-finalize-的区别。" class="headerlink" title="20、final, finally, finalize 的区别。"></a>20、final, finally, finalize 的区别。</h3><p>考察点：声明<br>回答：<br>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。<br>finally 是异常处理语句结构的一部分，表示总是执行。<br>finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/posts/beea.html"/>
      <url>/posts/beea.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、介绍一下-Syncronized-锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#1、介绍一下-Syncronized-锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>1、介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h3><p>考点：java  关键字<br>回答：<br>synchronized 修饰静态方法以及同步代码块的 synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。<br>synchronized 修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。</p><h3 id="2、介绍一下-volatile？"><a href="#2、介绍一下-volatile？" class="headerlink" title="2、介绍一下 volatile？"></a>2、介绍一下 volatile？</h3><p>考察点：java  关键字<br>回答：<br>volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高 CPU 的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先 Java 内存模<br>型分为，主内存，工作内存。比如线程 A 从主内存把变量从主内存读到了自己的工作内存中，做了加 1 的操作，但是此时没有将 i 的最新值刷新会主内存中，线程 B 此时读到的还是 i 的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的 CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。</p><h3 id="3、锁有了解嘛，说一下-Synchronized-和-lock"><a href="#3、锁有了解嘛，说一下-Synchronized-和-lock" class="headerlink" title="3、锁有了解嘛，说一下 Synchronized 和 lock"></a>3、锁有了解嘛，说一下 Synchronized 和 lock</h3><p>考察点：java  关键字</p><p>回答：<br>synchronized 是 Java 的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5 以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。<br>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock时需要在 finally 块中释放锁；Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断；通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p><h3 id="4、讲一讲-Java-里面的-final-关键字怎么用的？"><a href="#4、讲一讲-Java-里面的-final-关键字怎么用的？" class="headerlink" title="4、讲一讲 Java 里面的 final 关键字怎么用的？"></a>4、讲一讲 Java 里面的 final 关键字怎么用的？</h3><p>考察点：关键字<br>回答：<br>当用 final 修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用 final 进行修饰。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。<br>“使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的 Java 版本中，不需要使用 final方法进行这些优化了。“<br>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础部分3</title>
      <link href="/posts/2ce6.html"/>
      <url>/posts/2ce6.html</url>
      
        <content type="html"><![CDATA[<h3 id="21、你能比较一下-Java-和-JavaSciprt-吗？"><a href="#21、你能比较一下-Java-和-JavaSciprt-吗？" class="headerlink" title="21、你能比较一下 Java 和 JavaSciprt 吗？"></a>21、你能比较一下 Java 和 JavaSciprt 吗？</h3><p>考察： Java&amp;JavaScript<br>回答：<br>JavaScript 与 Java 是两个公司开发的不同的两个产品。Java 是原 Sun Microsystems 公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而 JavaScript 是 Netscape公司的产品，为了扩展 Netscape 浏览器的功能而开发的一种可以嵌入 Web 页面中运行的基于对象和事件驱动的解释性语言。JavaScript 的前身是 LiveScript；而 Java 的前身是 Oak 语言。<br>下面对两种语言间的异同作如下比较：</p><ul><li>基于对象和面向对象：Java 是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript 是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java 的源代码在执行之前，必须经过编译。JavaScript 是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了 JIT（即时编译）技术来提升 JavaScript 的运行效率）</li><li>强类型变量和类型弱变量：Java 采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript 中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript 的解释器在运行时检查推断其数据类型</li><li>代码格式不一样。</li></ul><h3 id="22、简述正则表达式及其用途。"><a href="#22、简述正则表达式及其用途。" class="headerlink" title="22、简述正则表达式及其用途。"></a>22、简述正则表达式及其用途。</h3><p>考察点：正则表达式<br>回答：</p><p>在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式<br>就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。计算机处理的<br>信息更多的时候不是数值而是字符串，正则表达式就是在进行字符串匹配和处理的时候最为强大<br>的工具，绝大多数语言都提供了对正则表达式的支持。</p><h3 id="23、Java-中是如何支持正则表达式操作的？"><a href="#23、Java-中是如何支持正则表达式操作的？" class="headerlink" title="23、Java 中是如何支持正则表达式操作的？"></a>23、Java 中是如何支持正则表达式操作的？</h3><p>考察点：正则表达式<br>回答：<br>Java 中的 String 类提供了支持正则表达式操作的方法，包括：matches()、replaceAll()、replaceFirst()、split()。此外，Java 中可以用 Pattern 类表示正则表达式对象，它提供了丰富的 API 进行各种正则表达式操作，如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Matcher<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>regex<span class="token punctuation">.</span>Pattern<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">RegExpTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        String str <span class="token operator">=</span> <span class="token string">"成都市(成华区)(武侯区)(高新区)"</span><span class="token punctuation">;</span>        Pattern p <span class="token operator">=</span> Pattern<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">".*?(?=\\()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Matcher m <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">matcher</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="24、请你说说-Java-和-PHP-的区别？"><a href="#24、请你说说-Java-和-PHP-的区别？" class="headerlink" title="24、请你说说 Java 和 PHP 的区别？"></a>24、请你说说 Java 和 PHP 的区别？</h3><p>考察点：Java  特性<br>回答：<br>PHP 暂时还不支持像 Java 那样 JIT 运行时编译热点代码,但是 PHP 具有 opcache 机制,能够把脚本对应的 opcode 缓存在内存,PHP7 中还支持配置 opcache.file_cache 导出 opcode 到文件.第三方的 Facebook HHVM 也支持 JIT.另外 PHP 官方基于 LLVM 围绕 opcache 机制构建的 Zend JIT分支也正在开发测试中.在 php-src/Zend/bench.php 测试显示,PHP JIT 分支速度是 PHP 5.4 的10 倍.<br>PHP 的库函数用 C 实现,而 Java 核心运行时类库(jdk/jre/lib/rt.jar,大于 60MB)用 Java 编写(jdk/src.zip), 所以 Java 应用运行的时候,用户编写的代码以及引用的类库和框架都要在 JVM上解释执行. Java 的 HotSpot 机制,直到有方法被执行 10000 次才会触发 JIT 编译, 在此之前运行在解释模式下,以避免出现 JIT 编译花费的时间比方法解释执行消耗的时间还要多的情况.<br>PHP 内置模板引擎,自身就是模板语言.而 Java Web 需要使用 JSP 容器如 Tomcat 或第三方模板引擎.</p><p>PHP 也可以运行在多线程模式下,比如 Apache 的 event MPM 和 Facebook 的 HHVM 都是多线程架构.不管是多进程还是多线程的 PHP Web 运行模式,都不需要 PHP 开发者关心和控制,也就是说PHP 开发者不需要写代码参与进程和线程的管理,这些都由 PHP-FPM/HHVM/Apache 实现.PHP-FPM进程管理和并发实现并不需要 PHP 开发者关心,而 Java 多线程编程需要 Java 开发者编码参与.PHP 一个 worker 进程崩溃,master 进程会自动新建一个新的 worker 进程,并不会导致 PHP 服务崩溃.而 Java 多线程编程稍有不慎(比如没有捕获异常)就会导致 JVM 崩溃退出.对于 PHP-FPM和 Apache MOD_PHP 来说,服务进程常驻内存,但一次请求释放一次资源,这种内存释放非常彻底.<br>PHP 基于引用计数的 GC 甚至都还没发挥作用程序就已经结束了。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 关键字 </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础部分2</title>
      <link href="/posts/ec27.html"/>
      <url>/posts/ec27.html</url>
      
        <content type="html"><![CDATA[<h3 id="11、什么是值传递和引用传递？"><a href="#11、什么是值传递和引用传递？" class="headerlink" title="11、什么是值传递和引用传递？"></a>11、什么是值传递和引用传递？</h3><p>考察点：JAVA  引用传递<br>回答：<br>值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身。所以对引用对象进行操作会同时改变原对象。一般认为,Java 内的传递都是值传递。</p><h3 id="12、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？"><a href="#12、数组-Array-和列表-ArrayList-有什么区别？什么时候应该使用-Array-而不是-ArrayList？" class="headerlink" title="12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？"></a>12、数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用 Array 而不是 ArrayList？</h3><p>考察点：Array</p><p>回答：<br>Array 和 ArrayList 的不同点：<br>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。<br>Array 大小是固定的，ArrayList 的大小是动态变化的。<br>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h3 id="13、你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？"><a href="#13、你了解大-O-符号-big-O-notation-么？你能给出不同数据结构的例子么？" class="headerlink" title="13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？"></a>13、你了解大 O 符号(big-O notation)么？你能给出不同数据结构的例子么？</h3><p>考察点：JAVA  notation<br>回答：<br>大 O 符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br>大 O 符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大 O 符号基于时间，内存和性能来选择最好的实现。大 O 符号可以对大量数据的性能给出一个很好的说明。<br>同时，大 O 符号表示一个程序运行时所需要的渐进时间复杂度上界。<br>其函数表示是：<br>对于函数 f(n),g(n),如果存在一个常数 c，使得 f(n)&lt;=c*g(n),则 f(n)=O(g(n));大 O 描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。大 O 还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大 O 符号基于时间，内存，性能选择最好的实现。大 O 符号可以对大量数据性能给予一个很好的说明。</p><h3 id="14、String-是最基本的数据类型吗"><a href="#14、String-是最基本的数据类型吗" class="headerlink" title="14、String 是最基本的数据类型吗?"></a>14、String 是最基本的数据类型吗?</h3><p>考察点：数据类型<br>回答：<br>基本数据类型包括 byte、int、char、long、float、double、boolean 和 short。java.lang.String 类是 final 类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用 StringBuffer 类</p><h3 id="15、int-和-Integer-有什么区别？"><a href="#15、int-和-Integer-有什么区别？" class="headerlink" title="15、int 和 Integer 有什么区别？"></a>15、int 和 Integer 有什么区别？</h3><p>考察点：数据类型</p><p>回答：<br>Java 提供两种不同的类型：引用类型和原始类型（或内置类型）。Int 是 java 的原始数据<br>类型，Integer 是 java 为 int 提供的封装类。<br>Java 为每个原始类型提供了封装类。<br>原始类型封装类<br>booleanBoolean<br>charCharacter<br>byteByte<br>shortShort<br>intInteger<br>longLong<br>floatFloat<br>doubleDouble<br>引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时<br>所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。</p><h3 id="16、String-和-StringBuffer-的区别？"><a href="#16、String-和-StringBuffer-的区别？" class="headerlink" title="16、String 和 StringBuffer 的区别？"></a>16、String 和 StringBuffer 的区别？</h3><p>考察点：数据类型<br>回答：<br>JAVA 平台提供了两个类：String 和 StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个 String 类提供了数值不可改变的字符串。而这个 StringBuffer 类提供的字符串进行修改。当你知道字符数据要<br>改变的时候你就可以使用 StringBuffer。典型地，你可以使用 StringBuffers 来动态构造字符数据。</p><h3 id="17、我们在-web-应用开发过程中经常遇到输出某种编码的字符，如-iso8859-1等，如何输出一个某种编码的字符串？"><a href="#17、我们在-web-应用开发过程中经常遇到输出某种编码的字符，如-iso8859-1等，如何输出一个某种编码的字符串？" class="headerlink" title="17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1等，如何输出一个某种编码的字符串？"></a>17、我们在 web 应用开发过程中经常遇到输出某种编码的字符，如 iso8859-1等，如何输出一个某种编码的字符串？</h3><p>考察点：数据类型</p><p>回答：</p><pre class=" language-java"><code class="language-java">Public String <span class="token function">translate</span> <span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>String tempStr <span class="token operator">=</span> “”<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>tempStr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>“ISO<span class="token operator">-</span><span class="token number">8859</span><span class="token operator">-</span><span class="token number">1</span>″<span class="token punctuation">)</span><span class="token punctuation">,</span> “GBK”<span class="token punctuation">)</span><span class="token punctuation">;</span>tempStr <span class="token operator">=</span> tempStr<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>err<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> tempStr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="18、int-和-Integer-有什么区别？"><a href="#18、int-和-Integer-有什么区别？" class="headerlink" title="18、int 和 Integer 有什么区别？"></a>18、int 和 Integer 有什么区别？</h3><p>考察点：数据类型<br>回答：<br>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><p>如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AutoUnboxingTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将 3 自动装箱成 Integer 类型</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false 两个引用没有引用同一对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true a 自动拆箱成 int 类型再和 c 比较</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="19、-amp-和-amp-amp-的区别"><a href="#19、-amp-和-amp-amp-的区别" class="headerlink" title="19、&amp;和&amp;&amp;的区别?"></a>19、&amp;和&amp;&amp;的区别?</h3><p>考察点：运算符<br>回答：<br>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是 true 整个表达式的值才true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals 比较，否则会产生 NullPointerException 异常。</p><h3 id="20、在-Java-中，如何跳出当前的多重嵌套循环？"><a href="#20、在-Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="20、在 Java 中，如何跳出当前的多重嵌套循环？"></a>20、在 Java 中，如何跳出当前的多重嵌套循环？</h3><p>考察点：循环<br>回答：<br>在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C和 C++中的 goto 语句，但是就像要避免使用 goto一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好）</p><blockquote><p>本文参考Java面试题库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础部分1</title>
      <link href="/posts/a65c.html"/>
      <url>/posts/a65c.html</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法-Javat特性"><a href="#基本语法-Javat特性" class="headerlink" title="基本语法   Javat特性"></a>基本语法   Javat特性</h2><h3 id="1、为什么重写-equals-还要重写-hashcode？"><a href="#1、为什么重写-equals-还要重写-hashcode？" class="headerlink" title="1、为什么重写 equals 还要重写 hashcode？"></a>1、为什么重写 equals 还要重写 hashcode？</h3><p>考点：Java基础</p><p>回答：</p><p>​        HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于 Object 类，其 hashcode 码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。                                    HashMap 中的比较 key 是这样的，先求出 key 的 hashcode(),比较其值是否相等，若相等再比较 equals(),若相等则认为他们是相等的。若 equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap 用来判断 key 是否相等的方法，其实是调用了 HashSet 判断加入元素 是否相等。重载 hashCode()是为了对同一个 key，能得到相同的 Hash Code，这样 HashMap 就可以定位到我们指定的 key 上。重载 equals()是为了向HashMap 表明当前对象和 key 上所保存的对象是相等的，这样我们才真正地获得了这个 key 所对应的这个键值对。</p><h3 id="2、说一下-map-的分类和常见的情况"><a href="#2、说一下-map-的分类和常见的情况" class="headerlink" title="2、说一下 map 的分类和常见的情况"></a>2、说一下 map 的分类和常见的情况</h3><p>考点：java 基础<br>回答：<br>        java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMapHashtable LinkedHashMap 和 TreeMap.<br>        Map 主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。<br>        Hashmap 是一个最常用的 Map,它根据键的 HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。 HashMap 最多只允许一条记录的键为 Null;允许多条记录的值为 Null;HashMap 不支持线程的同步，即任一时刻可以有多个线程同时写 HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections 的synchronizedMap 方法使 HashMap 具有同步的能力，或者使用 ConcurrentHashMap。<br>        Hashtable 与 HashMap 类似,它继承自 Dictionary 类，不同的是:它不允许记录的键或者值为空;它支持线程的同步，即任一时刻只有一个线程能写 Hashtable,因此也导致了 Hashtable在写入时会比较慢。</p><p>​        LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历LinkedHashMap 时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。<br>​        TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。<br>​        一般情况下，我们用的最多的是 HashMap,在 Map 中插入、删除和定位元素，HashMap 是最<br>好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。如果需要输出的<br>顺序和输入的相同,那么用 LinkedHashMap 可以实现,它还可以按读取顺序来排列.<br>​        HashMap 是一个最常用的 Map，它根据键的 hashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap 最多只允许一条记录的键为 NULL，允许多条记录的值为 NULL。<br>​        HashMap 不支持线程同步，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致性。如果需要同步，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有同步的能力。<br>​        Hashtable 与 HashMap 类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写 Hashtable，因此也导致了 Hashtable 在写入时会比较慢。<br>​        LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。<br>​        在遍历的时候会比HashMap慢TreeMap能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p><h3 id="3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？"><a href="#3、Object-若不重写-hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？"></a>3、Object 若不重写 hashCode()的话，hashCode()如何计算出来的？</h3><p>考点：基础<br>回答：<br>        Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</p><h3 id="4、-比较的是什么？"><a href="#4、-比较的是什么？" class="headerlink" title="4、==比较的是什么？"></a>4、==比较的是什么？</h3><p>考点：基础<br>回答：<br>        “==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回 true，否则返回 false。“==”如果两边是基本类型，就是比较数值是否相等。</p><h3 id="5、若对一个类不重写，它的-equals-方法是如何比较的？"><a href="#5、若对一个类不重写，它的-equals-方法是如何比较的？" class="headerlink" title="5、若对一个类不重写，它的 equals()方法是如何比较的？"></a>5、若对一个类不重写，它的 equals()方法是如何比较的？</h3><p>考点：基础<br>回答：<br>        比较是对象的地址。</p><h3 id="6、java8-新特性"><a href="#6、java8-新特性" class="headerlink" title="6、java8 新特性"></a>6、java8 新特性</h3><p>考察点： java8<br>回答：<br>Lambda 表达式 − Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中。方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。<br>新工具 − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。<br>Stream API −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到Java 中。<br>Date Time API − 加强对日期与时间的处理。<br>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。<br>Nashorn, JavaScript 引擎 − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用</p><h3 id="7、说说-Lamda-表达式的优缺点"><a href="#7、说说-Lamda-表达式的优缺点" class="headerlink" title="7、说说 Lamda 表达式的优缺点"></a>7、说说 Lamda 表达式的优缺点</h3><p>考察点：a Java  基础<br>回答：<br>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。<br>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><h3 id="8、一个十进制的数在内存中是怎么存的？"><a href="#8、一个十进制的数在内存中是怎么存的？" class="headerlink" title="8、一个十进制的数在内存中是怎么存的？"></a>8、一个十进制的数在内存中是怎么存的？</h3><p>考察点：计算机基础</p><p>回答：<br>补码的形式。</p><h3 id="9、为啥有时会出现-4-0-3-6-0-40000001-这种现象"><a href="#9、为啥有时会出现-4-0-3-6-0-40000001-这种现象" class="headerlink" title="9、为啥有时会出现 4.0-3.6=0.40000001 这种现象"></a>9、为啥有时会出现 4.0-3.6=0.40000001 这种现象</h3><p>考察点：计算机基础</p><p>回答：<br>原因简单来说是这样：2 进制的小数无法精确的表达 10 进制小数，计算机在计算 10 进制小数的过程中要先转换为 2 进制进行计算，这个过程中出现了误差。</p><h3 id="10、Java-支持的数据类型有哪些？什么是自动拆装箱？"><a href="#10、Java-支持的数据类型有哪些？什么是自动拆装箱？" class="headerlink" title="10、Java 支持的数据类型有哪些？什么是自动拆装箱？"></a>10、Java 支持的数据类型有哪些？什么是自动拆装箱？</h3><p>考察点：A JAVA  数据类型<br>回答：<br>Java 语言支持的 8 种基本数据类型是：<br>byte<br>short<br>int<br>long<br>float<br>double<br>boolean<br>char<br>自动装箱是 Java 编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把 int 转化成 Integer，double 转化成 Double，等等。反之就是自动拆箱。</p><blockquote><p>本文参考Java面试题库</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java SE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java SE </tag>
            
            <tag> 基本语法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
